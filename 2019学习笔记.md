# 笔记

标签（空格分隔）： presto hive mongDB 响应式编程 spring的状态机 缓存相关

---

presto参考文档：

 1. https://tech.meituan.com/2014/06/16/presto.html
 2. http://www.stay-stupid.com/?p=395
 

hive参考文档：

 1. https://blog.csdn.net/wangyang1354/article/details/50570903
 2. https://blog.csdn.net/LW_GHY/article/details/51469753
 3. https://www.jianshu.com/p/dbad3b3d40eb

MongoDB参考文档：

 1. https://www.w3cschool.cn/mongodb/mongodb-query.html
 

spring5的webflux参考资料：

 1. https://juejin.im/post/5b3a22a16fb9a024db5ff13e
 2. https://zhuanlan.zhihu.com/p/37846655
 3. https://github.com/pkpk1234/learn-reactor
 

spring的状态机参考资料：

 1. http://blog.didispace.com/spring-statemachine/
 


缓存相关参考资料：

2. http://zhuanlan.51cto.com/art/201806/577116.htm
3. https://tech.meituan.com/2017/03/17/cache-about.html


poi生成pdf文档：

 1. https://blog.csdn.net/makang456/article/details/70161037
 

mysql间歇锁
--------

https://blog.csdn.net/andyxm/article/details/44810417
https://zhuanlan.zhihu.com/p/48269420

需要强调一下：间隙锁在**主键索引、普通索引**上的性质略微有些差别。

所谓间隙锁，区别于行锁只锁住一行，间隙锁会锁住一个区间段的数据。

下面先讨论**主键索引**上的间隙锁：

比如：
```mysql
CREATE TABLE `test` (
  `id` int(1) NOT NULL AUTO_INCREMENT,
  `name` varchar(8) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `test` VALUES ('1', '小罗');
INSERT INTO `test` VALUES ('5', '小黄');
INSERT INTO `test` VALUES ('7', '小明');
INSERT INTO `test` VALUES ('11', '小红');
```
上面数据存在隐藏的间隙锁：

 1. (-infinity, 1]
 2. (1, 5]
 3. (5, 7]
 4. (7, 11]
 5. (11, +infinity]

然后执行如下的sql语句，会产生间隙锁。
```mysql
/* 开启事务1 */
BEGIN;
/* 查询 id 在 5 - 7 范围的数据并加记录锁 */
SELECT * FROM `test` WHERE `id` BETWEEN 5 AND 7 FOR UPDATE;
/* 延迟30秒执行，防止锁释放 */
SELECT SLEEP(30);

# 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句

/* 事务2插入一条 id = 3，name = '小张1' 的数据 */
INSERT INTO `test` (`id`, `name`) VALUES (3, '小张1'); # 正常执行

/* 事务3插入一条 id = 4，name = '小白' 的数据 */
INSERT INTO `test` (`id`, `name`) VALUES (4, '小白'); # 正常执行

/* 事务4插入一条 id = 6，name = '小东' 的数据 */
INSERT INTO `test` (`id`, `name`) VALUES (6, '小东'); # 阻塞

/* 事务5插入一条 id = 8， name = '大罗' 的数据 */
INSERT INTO `test` (`id`, `name`) VALUES (8, '大罗'); # 阻塞

/* 事务6插入一条 id = 9， name = '大东' 的数据 */
INSERT INTO `test` (`id`, `name`) VALUES (9, '大东'); # 阻塞

/* 事务7插入一条 id = 11， name = '李西' 的数据 */
INSERT INTO `test` (`id`, `name`) VALUES (11, '李西'); # 阻塞

/* 事务8插入一条 id = 12， name = '张三' 的数据 */
INSERT INTO `test` (`id`, `name`) VALUES (12, '张三'); # 正常执行

/* 提交事务1，释放事务1的锁 */
COMMIT;
```
上面的for update语句锁住了[5-7]、[7-11]**两个区间**的数据！！！

另外。如果for update语句或者delete语句操作的数据在数据库不存在，那么也会产生间隙锁，但是它们只会锁住紧邻的区间。比如，删除id=3的数据（忽略上面事务的sql产生的数据），那么会产生[1-5]的间歇锁。

下面再看一下**普通索引**上的间隙锁：
准备如下表结构及初始数据：
```mysql
# 注意：number 不是唯一值

CREATE TABLE `test1` (
  `id` int(1) NOT NULL AUTO_INCREMENT,
  `number` int(1) NOT NULL COMMENT '数字',
  PRIMARY KEY (`id`),
  KEY `number` (`number`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

# 初始化数据
INSERT INTO `test1` VALUES (1, 1);
INSERT INTO `test1` VALUES (5, 3);
INSERT INTO `test1` VALUES (7, 8);
INSERT INTO `test1` VALUES (11, 12);
```
 number 索引存在的隐藏间隙：
 
 1. (-infinity, 1]
 2. (1, 3]
 3. (3, 8]
 4. (8, 12]
 5. (12, +infinity]

然后执行如下的事务：
```mysql
/* 开启事务1 */
BEGIN;
/* 查询 number = 2 的数据并加记录锁 */
SELECT * FROM `test1` WHERE `number` = 2 FOR UPDATE;
/* 延迟30秒执行，防止锁释放 */
SELECT SLEEP(30);

# 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句

/* 事务2插入一条 number = 0 的数据 */
INSERT INTO `test1` (`number`) VALUES (0); # 正常执行

/* 事务3插入一条 number = 1 的数据 */
INSERT INTO `test1` (`number`) VALUES (1); # 被阻塞

/* 事务4插入一条 number = 2 的数据 */
INSERT INTO `test1` (`number`) VALUES (2); # 被阻塞

/* 事务5插入一条 number = 4 的数据 */
INSERT INTO `test1` (`number`) VALUES (4); # 正常执行

/* 事务6插入一条 number = 8 的数据 */
INSERT INTO `test1` (`number`) VALUES (8); # 正常执行

/* 事务7插入一条 number = 9 的数据 */
INSERT INTO `test1` (`number`) VALUES (9); # 正常执行

/* 事务8插入一条 number = 10 的数据 */
INSERT INTO `test1` (`number`) VALUES (10); # 正常执行

/* 提交事务1 */
COMMIT;
```

可以看到，上面的sql产生number索引了[1-3]的间隙锁。

再看下下面的sql：
```mysql
/* 开启事务1 */
BEGIN;
/* 查询 number = 5 的数据并加记录锁 */
SELECT * FROM `test1` WHERE `number` = 3 FOR UPDATE;
/* 延迟30秒执行，防止锁释放 */
SELECT SLEEP(30);

# 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句

/* 事务2插入一条 number = 0 的数据 */
INSERT INTO `test1` (`number`) VALUES (0); # 正常执行

/* 事务3插入一条 number = 1 的数据 */
INSERT INTO `test1` (`number`) VALUES (1); # 被阻塞

/* 事务4插入一条 number = 2 的数据 */
INSERT INTO `test1` (`number`) VALUES (2); # 被阻塞

/* 事务5插入一条 number = 4 的数据 */
INSERT INTO `test1` (`number`) VALUES (4); # 被阻塞

/* 事务6插入一条 number = 8 的数据 */
INSERT INTO `test1` (`number`) VALUES (8); # 正常执行

/* 事务7插入一条 number = 9 的数据 */
INSERT INTO `test1` (`number`) VALUES (9); # 正常执行

/* 事务8插入一条 number = 10 的数据 */
INSERT INTO `test1` (`number`) VALUES (10); # 正常执行

/* 提交事务1 */
COMMIT;
```
上面的sql，即便存在number=3的记录，但是还是产生了[1-8]的间隙锁。至于原因，我们先看一下下面的sql再解释:
```java
/* 开启事务1 */
BEGIN;
/* 查询 number = 5 的数据并加记录锁 */
SELECT * FROM `test1` WHERE `number` = 3 FOR UPDATE;
/* 延迟30秒执行，防止锁释放 */
SELECT SLEEP(30);

/* 事务1插入一条 id = 2， number = 1 的数据 */
INSERT INTO `test1` (`id`, `number`) VALUES (2, 1); # 阻塞

/* 事务2插入一条 id = 3， number = 2 的数据 */
INSERT INTO `test1` (`id`, `number`) VALUES (3, 2); # 阻塞

/* 事务3插入一条 id = 6， number = 8 的数据 */
INSERT INTO `test1` (`id`, `number`) VALUES (6, 8); # 阻塞

/* 事务4插入一条 id = 8， number = 8 的数据 */
INSERT INTO `test1` (`id`, `number`) VALUES (8, 8); # 正常执行

/* 事务5插入一条 id = 9， number = 9 的数据 */
INSERT INTO `test1` (`id`, `number`) VALUES (9, 9); # 正常执行

/* 事务6插入一条 id = 10， number = 12 的数据 */
INSERT INTO `test1` (`id`, `number`) VALUES (10, 12); # 正常执行

/* 事务7修改 id = 11， number = 12 的数据 */
UPDATE `test1` SET `number` = 5 WHERE `id` = 11 AND `number` = 12; # 阻塞

/* 提交事务1 */
COMMIT;
```
注意上面的事务3和事务4.事务3阻塞了，事务4却成功了。这是为啥？看看下面这张图：
![此处输入图片的描述][1]
如上图所示，存在原始数据id=7，number=8，因此事务4的id=8，number=8不会被阻塞。

 1. 在普通索引列上，**不管**是何种查询，只要加锁，都会产生间隙锁，这跟唯一索引不一样；
 2. 在普通索引跟唯一索引中，数据间隙的分析，数据行是**优先**根据**普通索引**排序，再根据唯一索引排序。
 4. 临键锁，是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。临键锁的主要目的，也是为了避免幻读(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。

 

 


  [1]: https://github.com/WQZ321123/learn/blob/master/image/mysql/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E7%9A%84%E9%97%B4%E9%9A%99%E9%94%81.jpg?raw=true