# 算法

标签（空格分隔）： 算法

---

合并两个有序链表
--------

思路,将一个链表的元素逐个插入拷贝到另外一个链表.拷贝单个元素的过程中,需要记录上一次元素插入的pos位置,下一次插入元素从pos+1位置开始往后寻找正确的插入位置.
```java
package com.audi.algorithm;

import java.util.LinkedList;
import java.util.List;

public class MergeTwoList {

    // merge two list, both are sorted, lower to higher
    public static List merge(List<Integer> list1, List<Integer> list2) {
        if (list1 == null && list2 == null) {
            return null;
        }
        if (list1 == null) {
            return list2;
        }
        if (list2 == null) {
            return list1;
        }

        List newList = null;

        // choose the longer list as the destList
        if (list1.size() > list2.size()) {
            newList = list1;

            copy(list2, list1);
        } else {
            newList = list2;

            copy(list1, list2);
        }

        return newList;
    }

    private static void copy(List<Integer> src, List<Integer> dst) {
        int pos = 0;
        int temp = 0;

        for (int i = 0; i < src.size(); i++) {
            temp = src.get(i);
            for (int j = pos; j < dst.size(); j++) {
                // 下面这个if判断主要是为了解决在newList的头部插入元素的问题
                if (pos == 0 && temp < dst.get(0)) {
                    dst.add(0, temp);
                    pos = j + 1;
                    break;
                }

                if (temp >= dst.get(j) && temp < dst.get(j + 1)) {
                    // 稳定排序
                    pos = j + 1;
                    dst.add(pos, temp);
                    break;
                }
            }
        }

    }

    public static void main(String[] args) {
        List<Integer> list1 = new LinkedList<>();
        list1.add(1);
        list1.add(2);
        list1.add(5);
        list1.add(9);

        List<Integer> list2 = new LinkedList<>();
        list2.add(2);
        list2.add(7);
        list2.add(8);
        list2.add(8);
        list2.add(9);
        list2.add(19);

        System.out.println("before merge:");
        System.out.println(list1);
        System.out.println(list2);
        System.out.println();
        List newList = merge(list1, list2);
        System.out.println("after merge:");
        System.out.println(newList);

    }
}
```

代码输出结果:
```java
before merge:
[1, 2, 5, 9]
[2, 7, 8, 8, 9, 19]

after merge:
[1, 2, 2, 5, 7, 8, 8, 9, 9, 19]

Process finished with exit code 0
```
0-1背包问题
-------

 
 https://www.cnblogs.com/xym4869/p/8513801.html
 
 参考上面的链接，重点是链接中的几张图，我贴在下面了：
 
 ![此处输入图片的描述][1]
 ![此处输入图片的描述][2]
 ![此处输入图片的描述][3]
 
 上面解释了递推公式的过程，以及原理。尤其注意图中的，当可以把第i个物品放入口袋的时候，那么也就是需要将之前的物品（不一定是之前的i-1个，因为还可能之前的某几个物品需要拿出来）放入容量为j-w(i)的背包中。
 
 此外，还需要注意的一点是：当背包装的物品的价值达到最大时，哪些物品被装入了，这个在上面的图中也有推倒。
 
 0-1背包问题的示例代码：
```java
 public int knapsack(int W, int N, int[] weights, int[] values) {
    int[][] dp = new int[N + 1][W + 1];
    for (int i = 1; i <= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = 1; j <= W; j++) {
            if (j >= w) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w] + v);
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[N][W];
}
```
 
 

 

最长公共子串
------

 
 https://leetcode.com/problems/maximum-length-of-repeated-subarray/
 
 注意它的状态转移公式，且区别于最长公共子序列。
 

移除所有重复节点（递归实现）
--

 - LeetCode203：Remove Linked List Elements

这道题，题意很简单，就是移除队列中**所有**的重复元素。本质上可以使用递归实现。下图是一个递归的解题思路，使用递归时，要有递归的函数**宏观**的语义认识。

![Remove Linked List Elements](./image/algorithm/c203.png)

解题时，可以将头结点和剩余的其他节点看成两部分，假设剩余节点以及经过removeElements函数移除了重复节点，那么此时只需要考虑头结点释放需要移除即可。

下面是实现及测试代码：
 
```java
package com.audi.c203;

import org.omg.Messaging.SyncScopeHelper;

import java.util.List;
import java.util.Random;

/**
 * Remove Linked List Elements
 *
 * @author: WangQuanzhou
 * @date: 2020/1/11 16:31
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if (head == null) {
            return null;
        }
        head.next = removeElements(head.next, val);
        return head.val == val ? head.next : head;
    }


    public static void main(String[] args) {
        ListNode head = new ListNode(1);
        ListNode tail = new ListNode(5);
        head.next = tail;
        for (int i = 1; i <= 5; i++) {
            tail.next = new ListNode(new Random().nextInt(10));
            tail = tail.next;
        }


        System.out.println("移除前：");
        tail = head;
        while (tail != null) {
            System.out.println(tail.val);
            tail = tail.next;
        }
        System.out.println();

        System.out.println("移除后：");
        Solution solution = new Solution();
        head = solution.removeElements(head, 5);
        tail = head;
        while (tail != null) {
            System.out.println(tail.val);
            tail = tail.next;
        }
        System.out.println();
    }
}
```

二叉搜索树
-----

实现二叉搜索树的增删改查，首先约定本搜索树不允许重复元素的出现。首先是add方法：
```java
package com.audi.bst;


/**
 * 二分搜索树
 * <p>
 * 存储的元素E由于需要是可比较的，因此需要继承自Comparable接口
 *
 * @author: WangQuanzhou
 * @date: 2020/1/20 8:29
 */
public class BST<E extends Comparable<E>> {
    class Node {
        // 属性定义成public可以直接访问，不需要get方法
        public E e;
        public Node left, right;

        public Node(E e) {
            this.e = e;
            left = null;
            right = null;
        }
    }


    private Node root;

    private Integer size;

    public BST() {
        root = null;
        size = 0;
    }

    /**
     * 添加元素，返回已有元素个数
     *
     * @param e
     * @return
     */
    public Integer add(E e) {

        // 如果根节点为空
        if (null == root) {
            root = new Node(e);
            return size++;
        }

        add(root, e);

        return size;
    }

    /**
     * 二叉树释放为空
     *
     * @return
     */
    public Boolean isEmpty() {
        return size == 0;
    }

    /**
     * 二叉树的大小
     *
     * @return
     */
    public Integer size() {
        return size;
    }

    private void add(Node node, E e) {
        // 不允许添加重复元素
        if (e.equals(node.e)) {
            return;
        }
        // 如果添加位置左右子树为空
        if (e.compareTo(node.e) < 0 && node.left == null) {
            Node left = new Node(e);
            node.left = left;
            size++;
            return;
        }
        if (e.compareTo(node.e) > 0 && node.right == null) {
            Node right = new Node(e);
            node.right = right;
            size++;
            return;
        }


        // 如果添加位置左右子树不为空，递归调用add
        if (e.compareTo(node.e) < 0) {
            add(node.left, e);
        }
        if (e.compareTo(node.e) > 0) {
            add(node.right, e);
        }
    }

}
```

为了验证我们的add操作是正确的，我们实现以下二叉树的递归遍历，打印输出，看看结果是否正确(这里以中序遍历为例进行演示)：
```java
    /**
     * 中序遍历二叉树
     */
    public void inOrder() {
        inOrder(root);
    }

    private void inOrder(Node root) {
        if (null == root) {
            return;
        }
        inOrder(root.left);
        System.out.print(root.e + " ");
        inOrder(root.right);
    }

    public static void main(String[] args) {
        BST<Integer> bst = new BST<>();
        for (int i = 0; i < 8; i++) {
            int temp = new Random().nextInt(100);
            System.out.print(temp + " ");
            bst.add(temp);
        }
        System.out.println();
        bst.inOrder();
    }
```
测试代码输出：
```java
55 12 26 11 97 56 17 43 
11 12 17 26 43 55 56 97 
```
然后是递归前序遍历的代码：
```java
    /**
     * 前序遍历
     */
    public void preOrder() {
        preOrder(root);
    }

    private void preOrder(Node root) {
        if (null == root) {
            return;
        }
        System.out.print(root.e + " ");
        preOrder(root.left);
        preOrder(root.right);
    }

    public static void main(String[] args) {
        BST<Integer> bst = new BST<>();
        for (int i = 0; i < 8; i++) {
            int temp = new Random().nextInt(100);
            System.out.print(temp + " ");
            bst.add(temp);
        }
        System.out.println();
        bst.preOrder();
        System.out.println();
        bst.inOrder();
    }
```

输出结果如下，这里展示了前序遍历和中序遍历结果的对比：
```java
98 65 5 2 72 11 22 90 
98 65 5 2 11 22 72 90 
2 5 11 22 65 72 90 98 
```
类似的，后续遍历代码如下：
```java
    /**
     * 后序遍历
     */
    public void postOrder() {
        postOrder(root);
    }

    private void postOrder(Node root) {
        if (null == root) {
            return;
        }
        postOrder(root.left);
        postOrder(root.right);
        System.out.print(root.e + " ");
    }
```

然后是一个contains查询方法：
```java
    /**
     * 判断某个元素是否在二叉树中
     *
     * @param e
     * @return true-存在  false-不存在
     */
    public Boolean contains(E e) {
        return contains(root, e);
    }

    private Boolean contains(Node root, E e) {
        if (root == null) {
            return Boolean.FALSE;
        }
        if (root.e.compareTo(e) == 0) {
            return Boolean.TRUE;
        }
        return contains(root.left, e) || contains(root.right, e);
    }
```
或者参照下面的写法，充分利用二分搜索树的节点性质，加快查询的速度：
```java
    // 看二分搜索树中是否包含元素e
    public boolean contains(E e){
        return contains(root, e);
    }

    // 看以node为根的二分搜索树中是否包含元素e, 递归算法
    private boolean contains(Node node, E e){

        if(node == null)
            return false;

        if(e.compareTo(node.e) == 0)
            return true;
        else if(e.compareTo(node.e) < 0)
            return contains(node.left, e);
        else // e.compareTo(node.e) > 0
            return contains(node.right, e);
    }
```

有的时候，可能我们在做二叉树的查询的时候，层序遍历二叉树查询效率来的更快，因此下面我们实现二叉树的层序遍历.

二叉树的层序遍历，需要借助额外的数据结构来暂存遍历过程中的二叉树的临时节点，这里我们使用FIFO的队列来保存遍历节点的左右子节点信息，源码如下：
```java
    /**
     * 二叉树的层序遍历，借助FIFO的队列实现
     */
    public void levelOrder() {
        if (root == null) {
            return;
        }
        LinkedList<Node> list = new LinkedList<>();
        list.add(root);
        while (!list.isEmpty()) {
            Node head = list.poll();
            System.out.println(head.e);
            if (head.left != null) {
                list.add(head.left);
            }
            if (head.right != null) {
                list.add(head.right);
            }
        }
    }
```

下面是二叉树的节点删除操作，删除操作，相对复杂一些，因为涉及元素节点的移动。

当待删除节点没有左子树时，直接删除该节点，并使用右子树替换该节点位置。右子树为空时也是一样的情况。

唯一复杂一点的是，当待删除节点的左右子树都不为空时，那么该怎么办？使用Hibbard Deletion理论，使用待删除节点右子树的最小值替换待删除节点，示意图如下：
![Hibbard-Deletion](./image/algorithm/QQ截图20200205224430.png)

为了实现删除操作，我们需要实现删除最小节点，查找最小节点，以及真正的删除方法：
```java
    // 寻找二分搜索树的最小元素
    public E minimum(){
        if(size == 0)
            throw new IllegalArgumentException("BST is empty!");

        return minimum(root).e;
    }

    // 返回以node为根的二分搜索树的最小值所在的节点
    private Node minimum(Node node){
        if(node.left == null)
            return node;
        return minimum(node.left);
    }

    // 寻找二分搜索树的最大元素
    public E maximum(){
        if(size == 0)
            throw new IllegalArgumentException("BST is empty");

        return maximum(root).e;
    }

    // 返回以node为根的二分搜索树的最大值所在的节点
    private Node maximum(Node node){
        if(node.right == null)
            return node;

        return maximum(node.right);
    }

    // 从二分搜索树中删除最小值所在节点, 返回最小值
    public E removeMin(){
        E ret = minimum();
        root = removeMin(root);
        return ret;
    }

    // 删除掉以node为根的二分搜索树中的最小节点
    // 返回删除节点后新的二分搜索树的根
    private Node removeMin(Node node){

        if(node.left == null){
            Node rightNode = node.right;
            node.right = null;
            size --;
            return rightNode;
        }

        node.left = removeMin(node.left);
        return node;
    }

    // 从二分搜索树中删除最大值所在节点
    public E removeMax(){
        E ret = maximum();
        root = removeMax(root);
        return ret;
    }

    // 删除掉以node为根的二分搜索树中的最大节点
    // 返回删除节点后新的二分搜索树的根
    private Node removeMax(Node node){

        if(node.right == null){
            Node leftNode = node.left;
            node.left = null;
            size --;
            return leftNode;
        }

        node.right = removeMax(node.right);
        return node;
    }

    // 从二分搜索树中删除元素为e的节点
    public void remove(E e){
        root = remove(root, e);
    }

    // 删除掉以node为根的二分搜索树中值为e的节点, 递归算法
    // 返回删除节点后新的二分搜索树的根
    private Node remove(Node node, E e){

        if( node == null )
            return null;

        if( e.compareTo(node.e) < 0 ){
            node.left = remove(node.left , e);
            return node;
        }
        else if(e.compareTo(node.e) > 0 ){
            node.right = remove(node.right, e);
            return node;
        }
        else{   // e.compareTo(node.e) == 0

            // 待删除节点左子树为空的情况
            if(node.left == null){
                Node rightNode = node.right;
                node.right = null;
                size --;
                return rightNode;
            }

            // 待删除节点右子树为空的情况
            if(node.right == null){
                Node leftNode = node.left;
                node.left = null;
                size --;
                return leftNode;
            }

            // 待删除节点左右子树均不为空的情况

            // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点
            // 用这个节点顶替待删除节点的位置
            Node successor = minimum(node.right);
            successor.right = removeMin(node.right);
            successor.left = node.left;

            node.left = node.right = null;

            return successor;
        }
    }
```

需要注意的是，由于删除操作可能会影响root节点（比如删除root节点），所以需要在remove方法返回最新的root节点。


堆
-

堆分为大堆和最小堆，其实他们很类似，只是父节点与子节点的大小关系的比较不一致而已。我们以最大堆为例。

https://www.jianshu.com/p/21bef3fc3030

最大堆有如下一些特性：

 - 它是一颗完全二叉树
 - 父结点的data域值都不小于（大于）其子结点的data域值

什么是完全二叉树？

假设二叉树有h层，那么h-1层及以上都是满二叉树。且第h层（叶子节点）节点均靠左分布。如下图所示：

![wanquanerchashu](./image/algorithm/完全二叉树.png)


 
  [1]: https://github.com/Audi-A7/learn/blob/master/image/interview/0-1%EF%BC%880%EF%BC%89.jpg?raw=true
  [2]: https://github.com/Audi-A7/learn/blob/master/image/interview/0-1%EF%BC%881%EF%BC%89.jpg?raw=true
  [3]: https://github.com/Audi-A7/learn/blob/master/image/interview/0-1%EF%BC%882%EF%BC%89.jpg?raw=true