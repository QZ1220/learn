# 面经整理

标签（空格分隔）： 整理

---

题目连接列表
======

 1. https://www.jianshu.com/p/5ad977cd3113
 2. https://www.jianshu.com/p/05d44e107470

针对[链接2][1]的笔记（字节跳动）
--------

 **1. 虚拟内存是什么干什么用的？**
 
https://blog.csdn.net/qq_30137611/article/details/66478426

虚拟内存的引入主要还是为了应对物理内存有限的情形,操作系统引入了虚拟内存,且加入了逻辑地址 物理地址的概念,CPU在请求资源数据的时候,一般都是先将虚拟地址给MMU(内存管理单元),MMU请求页表(页表中的数据,有可能在内存,也有可能在磁盘),获得虚拟地址对应的物理地址,如果物理地址对应的数据在磁盘,会首先将数据缓冲到内存,如果本身就在内存,那么直接返回物理地址对应位置的数据给CPU.

总结来说就是如下几步:

 - 第一步：处理器生成一个虚拟地址（VA），并把它传送给MMU
 - 第二步：MMU生成页表条目的地址（PTEA），请求内存中的页表，让它给自己返回一个页表条目（PTE）
 - 第三步：MMU构造物理地址（PA），然后把这这个物理地址传给内存（这时候是真实的物理地址），请求物理内存中的数据
 - 第四步：内存返回所请求的数据给处理器

下面是博客里的一张示意图:

![此处输入图片的描述][2]

 **1. HTTP协议包括哪几种请求?如何保证幂等性?**

https://www.cnblogs.com/ranyonsue/p/5984001.html

注意http协议是无状态的,即如果后续请求需要前面请求的信息,那么它必须进行重传.

http请求可以细分为8种,分别如下:

 - GET     请求指定的页面信息，并返回实体主体。
 - HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
 - POST    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
 - PUT     从客户端向服务器传送的数据取代指定的文档的内容。
 - DELETE      请求服务器删除指定的页面。
 - CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服器。
 - OPTIONS     允许客户端查看服务器的性能。
 - TRACE     回显服务器收到的请求，主要用于测试或诊断。

其中,HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

HTTP之请求消息Request

客户端发送一个HTTP请求到服务器的请求消息包括以下格式：**请求行（request line）、请求头部（header）、空行和请求数据**四个部分组成。如下图所示:
![此处输入图片的描述][3]

 - Get请求例子，使用Charles抓取的request：

```http
GET /562f25980001b1b106000338.jpg HTTP/1.1
Host    img.mukewang.com
User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36
Accept    image/webp,image/*,*/*;q=0.8
Referer    http://www.imooc.com/
Accept-Encoding    gzip, deflate, sdch
Accept-Language    zh-CN,zh;q=0.8

```
注意:请求头部后面的空行是必须的,即使第四部分的请求数据为空，也必须有空行(这个例子的请求数据为空).

 - POST请求例子，使用Charles抓取的request：
```http
POST / HTTP1.1
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive

name=Professional%20Ajax&publisher=Wiley
```


HTTP之响应消息Response

HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行(必须要有)和响应正文。如下图所示:
![此处输入图片的描述][4]

下面是一个具体的例子:
```http
HTTP/1.1 200 OK
Date: Fri, 22 May 2009 06:07:21 GMT
Content-Type: text/html; charset=UTF-8

<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body>
</html>
```

**http协议如何保证幂等性?**

https://blog.csdn.net/Patrick_1993/article/details/82633726

幂等性指的是一次请求和多次请求某一资源具有同样的副作用。比如，你采用 GET 请求银行账户的余额，虽然结果不一定相同，可是并无副作用，因此是幂等的。而如果采用 POST请求提交扣款，多次提交产生不同的副作用，因此不满足幂等性。

 - GET 请求用于获取资源，无副作用，所以是幂等的。
 - DELETE 请求用于删除资源，有副作用，但是，DELETE 同一资源，无论调用一次还是调用多次，其副作用是相同的，因此也满足幂等性。
 - PUT 方法用于创建或更新操作，有副作用，与 DELETE 相同，对同一资源无论调用一次还是多次，其副作用是相同的，因此也满足幂等性。
 - POST 方法与 PUT 方法的区别主要在于幂等性，**POST 不具备幂等性**，因为 POST 请求每次都会创建一个文件，而 PUT方法会在服务器验证是否有 ENTITY，若有则更新该 ENTITY而不是重新创建。

kkkk

 **1. 输入一个网址到浏览器渲染出页面的过程中有哪些报文，分别涉及哪些协议，协议的主要内容是啥，分别用来做什么的?**

https://blog.csdn.net/u014590757/article/details/80035410

 - 浏览器获取输入的域名www.baidu.com
 - 浏览器向DNS请求解析www.baidu.com的IP地址
 - 域名系统DNS解析出百度服务器的IP地址
 - 浏览器发出HTTP请求，请求百度首页
 - 浏览器与该服务器建立TCP连接(默认端口号80)
 - 服务器通过HTTP响应把首页文件发送给浏览器
 - TCP连接释放
 - 浏览器将首页文件进行解析，并将Web页显示给用户。

涉及到的相关协议:

(1) 应用层：HTTP(WWW访问协议)，DNS(域名解析服务) 
DNS解析域名为目的IP，通过IP找到服务器路径，客户端向服务器发起HTTP会话，然后通过运输层TCP协议封装数据包，在TCP协议基础上进行传输

(2) 传输层：TCP(为HTTP提供可靠的数据传输)，UDP(DNS使用UDP传输) 
HTTP会话会被分成报文段，添加源、目的端口；TCP协议进行主要工作

(3)网络层：IP(IP数据数据包传输和路由选择)，ICMP(提供网络传输过程中的差错检测)，ARP(将本机的默认网关IP地址映射成物理MAC地址) 为数据包选择路由，ARP协议将IP地址转成MAC地址。

数据流向:HTTP数据包(应用层)->TCP报文段(传输层)->IP数据包(网络层)->数据帧(数据链路层)

 **1. 如果让你设计一个下载器中的断点续传功能，你打算怎么设计，会有哪些问题?**
 
 https://www.jianshu.com/p/75271ec07c75
 
 https://blog.csdn.net/zgaoq/article/details/72778922
 
 

 **1. 概率问题**

 有一个袋子里面装了黑白两种颜色的球若干个，现在每次从袋子里面摸两个球，如果摸到的是相同颜色的球那么将两个球丢弃并且重新放一个黑球进去，如果摸到的是不同颜色的球则将黑球白球放回，问最后袋子里面存在哪些情况并且详细说明过程，推导方法。
 
 

 - N黑(N为奇偶数都行)->1黑

 

 - N白(N为奇数)->1白1黑

 

 - N白(N为偶数)->1黑

 

 - M黑N白(M为奇偶数无所谓,N为奇)->1白1黑

 

 - M黑N白(M为奇偶数无所谓,N为偶)->1黑

 
 综上:最后只会1黑or1白1黑
 

如果将问题修改成摸到相同颜色的球直接丢弃不放回的话，这个时候整个过程会有哪些变化。

纯色球的时候,黑白都一样,以白球为例:

N白(N为奇数)->1白

N白(N为偶数)->0个球

M黑N白->1黑  or 1白 or  1黑1白  or 0个球

 **1. 有一台服务器，含有若干的CPU和内存资源，现在有一系列规格不等的虚拟机，设计算法最大化的利用服务器的资源并分析求解的复杂度?**
 
 这题的解题思路应该是使用贪心算法,后面再解决.
 

 **1. 手撕代码，给一个数组，将数组看做二叉树，输出二叉树的右半边部分，每一层要求逆序输出.**
 
 数组应该是按照层次遍历的方式输入的.其实,题目的意思,已知树的层次遍历,要输出树的右子树.
 
 

 **1. 什么是堆?最大堆最小堆?堆排序?**
 
 https://www.cnblogs.com/bakari/p/5490858.html
 
 这里所说的堆不是内存中的堆,而是一种数据结构,堆通常可以被看做是树结构，满足两个性质：**1）**堆中任意节点的值总是不大于（不小于）其子节点的值；**2）**堆是一棵完全树。
 
 **最大堆:**根节点的值不小于左右节点的值
 
 **最小堆:**根节点的值不大于左右节点的值
 
 http://www.cnblogs.com/dolphin0520/archive/2011/10/06/2199741.html
 
 堆排序的基本思想:首先构建最大(小)堆,然后将堆顶元素R1和Rn交换,调整树结构使其再次满足堆性质,然后重复上面的过程,知道交换了N-1次,就完成了堆排序.
 
 

 **1. TCP与UDP的区别**


 - TCP是有连接的,UDP是无无连接的；
 - 对系统资源的要求（TCP较多，UDP少）
 - TCP是**流**模式，UDP是**数据报**模式，原因可以参见https://www.cnblogs.com/jason2013/articles/4346639.html，总结来说就是：TCP由于可以保证顺序，且是一对一的通信，因此一次send多少或者一次receive多少，总是可以恢复出正确的信息。但是UDP不行，它不能保证顺序，且存在多个send一个receive的情况，假如来自两个send的报文信息合并了，那么将不能恢复出正确的原始信息来。
 - TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证
 - http协议（应用层）使用的就是TCP（传输层），常见的使用TCP还有FTP、SMTP、Telnet、QQ文件传输等。
 - DNS服务（原因层）使用的是UDP(传输层)，常见的使用UDP的还有语音电话、视频电话等。


----------

 **1. CAS用途及原理？**

https://www.cnblogs.com/longshiyVip/p/5211478.html

CAS，Compare And Swap，它含有三个操作数，内存数据v，旧的预期数据A，要修改的数据B，每次进行数据更新时，当且仅当预期值A和内存中的数据V相同时，才将内存中的数据修改为B，否则什么也不做。

使用这种机制编写的算法也叫非阻塞算法。

基本上JDK中atomic包下的很多类都是使用了这个原理，我们简单看一下AtomicInteger的部分源码：
```java
/**
     * Atomically updates the current value with the results of
     * applying the given function, returning the previous value. The
     * function should be side-effect-free, since it may be re-applied
     * when attempted updates fail due to contention among threads.
     *
     * @param updateFunction a side-effect-free function
     * @return the previous value
     * @since 1.8
     */
    public final int getAndUpdate(IntUnaryOperator updateFunction) {
        int prev, next;
        do {
            prev = get();
            next = updateFunction.applyAsInt(prev);
        } while (!compareAndSet(prev, next));
        return prev;
    }
    
    
    /**
     * Atomically sets the value to the given updated value
     * if the current value {@code ==} the expected value.
     *
     * @param expect the expected value
     * @param update the new value
     * @return {@code true} if successful. False return indicates that
     * the actual value was not equal to the expected value.
     */
    public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }
```
上面的Unsafe为JNI的代码，锁分两种，一个叫悲观锁，一种称之为乐观锁。Synchronized就是悲观锁的一种，也称之为独占锁，加了synchronized关键字的代码基本上就只能以单线程的形式去执行了，它会导致其他需要该资源的线程挂起，直到前面的线程执行完毕释放所资源。而另外一种乐观锁是一种更高效的机制，它的原理就是每次不加锁去执行某项操作，如果发生冲突则失败并重试，直到成功为止，其实本质上不算锁，所以很多地方也称之为自旋（比如上面代码中的while循环）。

 **1. atomic包下有哪些实现类？原理是什么？**
 
 atomic包下的类，我们可以看一下下面的截图：
 
 ![此处输入图片的描述][5]

 atomic包中的操作原理大都基于CAS，具体的可以参考上面的笔记。
 
 

 **1. 0-1背包问题**
 
 https://www.cnblogs.com/xym4869/p/8513801.html
 
 参考上面的链接，重点是链接中的几张图，我贴在下面了：
 
 ![此处输入图片的描述][6]
 ![此处输入图片的描述][7]
 ![此处输入图片的描述][8]
 
 上面解释了递推公式的过程，以及原理。尤其注意图中的，当可以把第i个物品放入口袋的时候，那么也就是需要将之前的物品（不一定是之前的i-1个，因为还可能之前的某几个物品需要拿出来）放入容量为j-w(i)的背包中。

 

 
 
 

 
 
 
 
 

 
 

 
 


  [1]: https://www.jianshu.com/p/05d44e107470
  [2]: https://github.com/WQZ321123/learn/blob/master/image/interview/VM.png?raw=true
  [3]: https://github.com/WQZ321123/learn/blob/master/image/interview/Http%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84.png?raw=true
  [4]: https://github.com/WQZ321123/learn/blob/master/image/interview/http%E5%93%8D%E5%BA%94%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.jpg?raw=true
  [5]: https://github.com/WQZ321123/learn/blob/master/image/interview/atomic%E5%8C%85.png?raw=true
  [6]: https://github.com/WQZ321123/learn/blob/master/image/interview/0-1%EF%BC%880%EF%BC%89.jpg?raw=true
  [7]: https://github.com/WQZ321123/learn/blob/master/image/interview/0-1%EF%BC%881%EF%BC%89.jpg?raw=true
  [8]: https://github.com/WQZ321123/learn/blob/master/image/interview/0-1%EF%BC%882%EF%BC%89.jpg?raw=true