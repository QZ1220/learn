# 面经整理

标签（空格分隔）： 整理

---

题目连接列表
======

 1. https://www.jianshu.com/p/5ad977cd3113
 2. https://www.jianshu.com/p/05d44e107470

针对[链接2][1]的笔记（字节跳动）
--------

 **1. 虚拟内存是什么干什么用的？**
 
https://blog.csdn.net/qq_30137611/article/details/66478426

虚拟内存的引入主要还是为了应对物理内存有限的情形,操作系统引入了虚拟内存,且加入了逻辑地址 物理地址的概念,CPU在请求资源数据的时候,一般都是先将虚拟地址给MMU(内存管理单元),MMU请求页表(页表中的数据,有可能在内存,也有可能在磁盘),获得虚拟地址对应的物理地址,如果物理地址对应的数据在磁盘,会首先将数据缓冲到内存,如果本身就在内存,那么直接返回物理地址对应位置的数据给CPU.

总结来说就是如下几步:

 - 第一步：处理器生成一个虚拟地址（VA），并把它传送给MMU
 - 第二步：MMU生成页表条目的地址（PTEA），请求内存中的页表，让它给自己返回一个页表条目（PTE）
 - 第三步：MMU构造物理地址（PA），然后把这这个物理地址传给内存（这时候是真实的物理地址），请求物理内存中的数据
 - 第四步：内存返回所请求的数据给处理器

下面是博客里的一张示意图:

![此处输入图片的描述][2]

 **1. HTTP协议包括哪几种请求?如何保证幂等性?**

https://www.cnblogs.com/ranyonsue/p/5984001.html

注意http协议是无状态的,即如果后续请求需要前面请求的信息,那么它必须进行重传.

http请求可以细分为8种,分别如下:

 - GET     请求指定的页面信息，并返回实体主体。
 - HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
 - POST    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
 - PUT     从客户端向服务器传送的数据取代指定的文档的内容。
 - DELETE      请求服务器删除指定的页面。
 - CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服器。
 - OPTIONS     允许客户端查看服务器的性能。
 - TRACE     回显服务器收到的请求，主要用于测试或诊断。

其中,HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

HTTP之请求消息Request

客户端发送一个HTTP请求到服务器的请求消息包括以下格式：**请求行（request line）、请求头部（header）、空行和请求数据**四个部分组成。如下图所示:
![此处输入图片的描述][3]

 - Get请求例子，使用Charles抓取的request：

```http
GET /562f25980001b1b106000338.jpg HTTP/1.1
Host    img.mukewang.com
User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36
Accept    image/webp,image/*,*/*;q=0.8
Referer    http://www.imooc.com/
Accept-Encoding    gzip, deflate, sdch
Accept-Language    zh-CN,zh;q=0.8

```
注意:请求头部后面的空行是必须的,即使第四部分的请求数据为空，也必须有空行(这个例子的请求数据为空).

 - POST请求例子，使用Charles抓取的request：
```http
POST / HTTP1.1
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive

name=Professional%20Ajax&publisher=Wiley
```


HTTP之响应消息Response

HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行(必须要有)和响应正文。如下图所示:
![此处输入图片的描述][4]

下面是一个具体的例子:
```http
HTTP/1.1 200 OK
Date: Fri, 22 May 2009 06:07:21 GMT
Content-Type: text/html; charset=UTF-8

<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body>
</html>
```

**http协议如何保证幂等性?**

https://blog.csdn.net/Patrick_1993/article/details/82633726

幂等性指的是一次请求和多次请求某一资源具有同样的副作用。比如，你采用 GET 请求银行账户的余额，虽然结果不一定相同，可是并无副作用，因此是幂等的。而如果采用 POST请求提交扣款，多次提交产生不同的副作用，因此不满足幂等性。

 - GET 请求用于获取资源，无副作用，所以是幂等的。
 - DELETE 请求用于删除资源，有副作用，但是，DELETE 同一资源，无论调用一次还是调用多次，其副作用是相同的，因此也满足幂等性。
 - PUT 方法用于创建或更新操作，有副作用，与 DELETE 相同，对同一资源无论调用一次还是多次，其副作用是相同的，因此也满足幂等性。
 - POST 方法与 PUT 方法的区别主要在于幂等性，**POST 不具备幂等性**，因为 POST 请求每次都会创建一个文件，而 PUT方法会在服务器验证是否有 ENTITY，若有则更新该 ENTITY而不是重新创建。

kkkk

 **1. 输入一个网址到浏览器渲染出页面的过程中有哪些报文，分别涉及哪些协议，协议的主要内容是啥，分别用来做什么的?**

https://blog.csdn.net/u014590757/article/details/80035410

 - 浏览器获取输入的域名www.baidu.com
 - 浏览器向DNS请求解析www.baidu.com的IP地址
 - 域名系统DNS解析出百度服务器的IP地址
 - 浏览器发出HTTP请求，请求百度首页
 - 浏览器与该服务器建立TCP连接(默认端口号80)
 - 服务器通过HTTP响应把首页文件发送给浏览器
 - TCP连接释放
 - 浏览器将首页文件进行解析，并将Web页显示给用户。

涉及到的相关协议:

(1) 应用层：HTTP(WWW访问协议)，DNS(域名解析服务) 
DNS解析域名为目的IP，通过IP找到服务器路径，客户端向服务器发起HTTP会话，然后通过运输层TCP协议封装数据包，在TCP协议基础上进行传输

(2) 传输层：TCP(为HTTP提供可靠的数据传输)，UDP(DNS使用UDP传输) 
HTTP会话会被分成报文段，添加源、目的端口；TCP协议进行主要工作

(3)网络层：IP(IP数据数据包传输和路由选择)，ICMP(提供网络传输过程中的差错检测)，ARP(将本机的默认网关IP地址映射成物理MAC地址) 为数据包选择路由，ARP协议将IP地址转成MAC地址。

数据流向:HTTP数据包(应用层)->TCP报文段(传输层)->IP数据包(网络层)->数据帧(数据链路层)

 **1. 如果让你设计一个下载器中的断点续传功能，你打算怎么设计，会有哪些问题?**
 
 https://www.jianshu.com/p/75271ec07c75
 
 https://blog.csdn.net/zgaoq/article/details/72778922
 
 

 **1. 概率问题**

 有一个袋子里面装了黑白两种颜色的球若干个，现在每次从袋子里面摸两个球，如果摸到的是相同颜色的球那么将两个球丢弃并且重新放一个黑球进去，如果摸到的是不同颜色的球则将黑球白球放回，问最后袋子里面存在哪些情况并且详细说明过程，推导方法。
 
 

 - N黑(N为奇偶数都行)->1黑

 

 - N白(N为奇数)->1白1黑

 

 - N白(N为偶数)->1黑

 

 - M黑N白(M为奇偶数无所谓,N为奇)->1白1黑

 

 - M黑N白(M为奇偶数无所谓,N为偶)->1黑

 
 综上:最后只会1黑or1白1黑
 

如果将问题修改成摸到相同颜色的球直接丢弃不放回的话，这个时候整个过程会有哪些变化。

纯色球的时候,黑白都一样,以白球为例:

N白(N为奇数)->1白

N白(N为偶数)->0个球

M黑N白->1黑  or 1白 or  1黑1白  or 0个球

 **1. 有一台服务器，含有若干的CPU和内存资源，现在有一系列规格不等的虚拟机，设计算法最大化的利用服务器的资源并分析求解的复杂度?**
 
 这题的解题思路应该是使用贪心算法,后面再解决.
 

 **1. 手撕代码，给一个数组，将数组看做二叉树，输出二叉树的右半边部分，每一层要求逆序输出.**
 
 数组应该是按照层次遍历的方式输入的.其实,题目的意思,已知树的层次遍历,要输出树的右子树.
 
 

 **1. 什么是堆?最大堆最小堆?堆排序?**
 
 https://www.cnblogs.com/bakari/p/5490858.html
 
 这里所说的堆不是内存中的堆,而是一种数据结构,堆通常可以被看做是树结构，满足两个性质：**1）**堆中任意节点的值总是不大于（不小于）其子节点的值；**2）**堆是一棵完全树。
 
 **最大堆:**根节点的值不小于左右节点的值
 
 **最小堆:**根节点的值不大于左右节点的值
 
 http://www.cnblogs.com/dolphin0520/archive/2011/10/06/2199741.html
 
 堆排序的基本思想:首先构建最大(小)堆,然后将堆顶元素R1和Rn交换,调整树结构使其再次满足堆性质,然后重复上面的过程,知道交换了N-1次,就完成了堆排序.
 
 

 **1. TCP与UDP的区别**


 - TCP是有连接的,UDP是无无连接的；
 - 对系统资源的要求（TCP较多，UDP少）
 - TCP是**流**模式，UDP是**数据报**模式，原因可以参见https://www.cnblogs.com/jason2013/articles/4346639.html，总结来说就是：TCP由于可以保证顺序，且是一对一的通信，因此一次send多少或者一次receive多少，总是可以恢复出正确的信息。但是UDP不行，它不能保证顺序，且存在多个send一个receive的情况，假如来自两个send的报文信息合并了，那么将不能恢复出正确的原始信息来。
 - TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证
 - http协议（应用层）使用的就是TCP（传输层），常见的使用TCP还有FTP、SMTP、Telnet、QQ文件传输等。
 - DNS服务（原因层）使用的是UDP(传输层)，常见的使用UDP的还有语音电话、视频电话等。


----------

 **1. CAS用途及原理？**

https://www.cnblogs.com/longshiyVip/p/5211478.html

CAS，Compare And Swap，它含有三个操作数，内存数据v，旧的预期数据A，要修改的数据B，每次进行数据更新时，当且仅当预期值A和内存中的数据V相同时，才将内存中的数据修改为B，否则什么也不做。

使用这种机制编写的算法也叫非阻塞算法。

基本上JDK中atomic包下的很多类都是使用了这个原理，我们简单看一下AtomicInteger的部分源码：
```java
/**
     * Atomically updates the current value with the results of
     * applying the given function, returning the previous value. The
     * function should be side-effect-free, since it may be re-applied
     * when attempted updates fail due to contention among threads.
     *
     * @param updateFunction a side-effect-free function
     * @return the previous value
     * @since 1.8
     */
    public final int getAndUpdate(IntUnaryOperator updateFunction) {
        int prev, next;
        do {
            prev = get();
            next = updateFunction.applyAsInt(prev);
        } while (!compareAndSet(prev, next));
        return prev;
    }
    
    
    /**
     * Atomically sets the value to the given updated value
     * if the current value {@code ==} the expected value.
     *
     * @param expect the expected value
     * @param update the new value
     * @return {@code true} if successful. False return indicates that
     * the actual value was not equal to the expected value.
     */
    public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }
```
上面的Unsafe为JNI的代码，锁分两种，一个叫悲观锁，一种称之为乐观锁。Synchronized就是悲观锁的一种，也称之为独占锁，加了synchronized关键字的代码基本上就只能以单线程的形式去执行了，它会导致其他需要该资源的线程挂起，直到前面的线程执行完毕释放所资源。而另外一种乐观锁是一种更高效的机制，它的原理就是每次不加锁去执行某项操作，如果发生冲突则失败并重试，直到成功为止，其实本质上不算锁，所以很多地方也称之为自旋（比如上面代码中的while循环）。

 **1. atomic包下有哪些实现类？原理是什么？**
 
 atomic包下的类，我们可以看一下下面的截图：
 
 ![此处输入图片的描述][5]

 atomic包中的操作原理大都基于CAS，具体的可以参考上面的笔记。
 
 

 **1. 0-1背包问题**
 
 https://www.cnblogs.com/xym4869/p/8513801.html
 
 参考上面的链接，重点是链接中的几张图，我贴在下面了：
 
 ![此处输入图片的描述][6]
 ![此处输入图片的描述][7]
 ![此处输入图片的描述][8]
 
 上面解释了递推公式的过程，以及原理。尤其注意图中的，当可以把第i个物品放入口袋的时候，那么也就是需要将之前的物品（不一定是之前的i-1个，因为还可能之前的某几个物品需要拿出来）放入容量为j-w(i)的背包中。
 
 此外，还需要注意的一点是：当背包装的物品的价值达到最大时，哪些物品被装入了，这个在上面的图中也有推倒。
 
 0-1背包问题的示例代码：
 
 ```java
 public int knapsack(int W, int N, int[] weights, int[] values) {
    int[][] dp = new int[N + 1][W + 1];
    for (int i = 1; i <= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = 1; j <= W; j++) {
            if (j >= w) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w] + v);
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[N][W];
}
 ```
 
 

 **1. 最长公共子串**
 
 https://leetcode.com/problems/maximum-length-of-repeated-subarray/
 
 注意它的状态转移公式，且区别于最长公共子序列。
 
 

**1. redis的数据结构**

http://www.cnblogs.com/wxd0108/p/5729739.html

http://www.redis.net.cn/order/3593.html
 
 | 结构类型        | 可存储数据格式   |  数量  |相关指令|
| --------   | :-----:  | :----:  | :---- |
| String字符串     | 字符串，整数或者浮点数 |   对整个字符串或者字符串中的一部分执行操作，对整个整数或者浮点执行自增(increment)或者自减(decrement)操作     | 1、get、获取存储在指定键中的值 2、set、设置存储在指定键中的值 3、del、删除存储在指定键中的值（这个命令可以用于所有的类型）|
| List列表        |   一个链表，链表上的每个节点都包含了一个字符串   |   从链表的两端推入或者弹出元素，根据偏移量对链表进行修剪(trim)，读取单个或者多个元素，根据值查找或者移除元素   |1、rpush、将给定值推入列表的右端   2、lrange、获取列表在指定范围上的所有值  3、lindex、获取列表在指定范围上的单个元素  4、lpop、从列表的左端弹出一个值，并返回被弹出的值|
| Set集合        |    包含字符串的无序收集器（不可重复）   |  添加，获取，移除单个元素，检查一个元素是否存在于集合中，计算交集，并集，差集，从集合里面随机获取元素  |1、sadd、将给定元素添加到集合  2、smembers、返回集合包含的所有元素  3、sismember、检查指定元素是否存在于集合中  4、srem、检查指定元素是否存在于集合中，那么移除这个元素|
| Hash散列        |   包含key-value键值对无序散列表     |  添加，获取，移除当键值对，获取所有键值对  |1、hset、在散列里面关联起指定的键值对 2、hget、获取指定散列键的值 3、hgetall、获取散列包含的所有键值对 4、hdel、如果给定键存在于散列里面，那么移除这个键|
| Zset有序集合       |   字符串成员(member)与浮点数分值(score)之间的有序映射(score可以重复，但是member不能重复)    |  元素的排列顺序由分值的大小决定。添加，获取，删除单个元素，根据分值范围(range)或者成员来获取元素  |1、zadd、将一个带有给定分值的成员添加到有序集合里面 2、zrange、根据元素在有序排列中所处的位置，从有序集合里面获取多个元素 3、zrangebyscore、获取有序集合在给定分值范围内的所有元素 4、zrem、如果指定成员存在于有序集合中，那么移除这个成员|

**注意**：zset不能member重复，但是可以分值重复。member重复添加的时候，之前的member节点会被删除，新的member节点会被插入。分值重复的时候，节点的先后顺序按照member的字典序进行排序。

 **1. redis的keys命令在生产环境可以使用吗？**
 
 http://www.cnblogs.com/joshua317/p/5533917.html
 
 **不可以**，绝对不可以。由于执行keys命令，redis会锁定，如果数据庞大的话可能需要几秒或更长，对于生产服务器上锁定几秒这绝对是灾难了
 
 redis官方文档对于keys命令的warning解释：
 
 Warning: consider KEYS as a command that should only be used in production environments with extreme care. It may ruin performance when it is executed against large databases. This command is intended for debugging and special operations, such as changing your keyspace layout. Don’t use KEYS in your regular application code. If you’re looking for a way to find keys in a subset of your keyspace, consider using SCAN or sets.
 
 
 如果有这种需求的话可以自己对键值做索引，比如把各种键值存到不同的set里面，分类建立索引，这样就可以很快的得到数据，但是这样也存在一个明显的缺点，就是浪费宝贵的空间，要知道这可是内存空间啊，所以还是要合理考虑，当然也可以想办法，比如对于有规律的键值，可以存储他们的始末值等等。
 
 从redis的官方文档上看，2.8版本之后SCAN命令已经可用，允许使用游标从keyspace中检索键。对比KEYS命令，虽然SCAN无法一次性返回所有匹配结果，但是却规避了阻塞系统这个高风险，从而也让一些操作可以放在主节点上执行。

需要注意的是，SCAN 命令是一个基于游标的迭代器。SCAN 命令每次被调用之后， 都会向用户返回一个新的游标，用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数， 以此来延续之前的迭代过程。同时，使用SCAN，用户还可以使用keyname模式和count选项对命令进行调整。SCAN相关命令还包括SSCAN 命令、HSCAN 命令和 ZSCAN 命令，分别用于集合、哈希键及有续集等。


 

 **1. redis的跳跃表是怎么实现的？有什么用？为什么使用跳表而不使用平衡树？**
 
 https://blog.csdn.net/lz710117239/article/details/78408919
 
 跳表主要用于有序集合zset中，若一个有序集合包含的元素数量比较多，或者有序集合中的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。
 
 redis跳表底层实现，本质来说就是一个改良过的双向链表，每次创建一个新跳跃表结点的时候，程序都根据幂次定律（power law，越大的数出现的概率越小）随机生成一个介于**1和32**之间的值作为level数组的大小，这个大小就是该结点包含的层数。
 以下是跳跃表节点的定义：
 ```c++
 typedef struct zskiplistNode {  
    robj *obj;  
    double score;  
    struct zskiplistNode *backward;  
    struct zskiplistLevel {  
        struct zskiplistNode *forward;  
        unsigned int span;  
    } level[];  
} zskiplistNode;  
 ```
 代码中的span的概念，就是为了表明当前节点与forward指向的后向节点的之间的层跨度。
 
 下面是跳跃表的示意图：
 
 ![此处输入图片的描述][9]
 
  跳跃表头结点（header指向的节点）排名为0，之后的节点排名以此类推。在上图跳跃表中查找计算分值为3.0、成员对象为o3的结点的排名。查找过程只遍历了头结点的L5层就找到了，并且头结点该层的跨度为3，因此得到该结点在跳跃表中的排名为3。
  
  **为什么使用跳表而不使用平衡树？**
  
  https://blog.csdn.net/u010412301/article/details/64923131
  

 - skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。
 - 在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。
 - 平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。
 - 从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。
 - 查找单个key，skiplist和平衡树的时间复杂度都为O(logn)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。
 - 从算法实现难度上来比较，skiplist比平衡树要简单得多。

lll

 **1. http的三次握手过程？为什么不是两次或者四次？**
 
 https://www.cnblogs.com/qdhxhz/p/8470997.html
 
 https://www.zhihu.com/question/24853633
 
 https://blog.csdn.net/lengxiao1993/article/details/82771768
 
 首先简要介绍一下tcp的6种标志位：
 SYN(建立联机)  ACK(确认)   PSH(传送)   FIN(结束)   RST(重置)    URG(紧急)  Sequence number(顺序号码)     Acknowledge number(确认号码)
 
 下面先说一下为什么不是**2次**握手？
 
 其实主要的原因还是因为，TCP为了保证可靠连接，通信的双方需要维护一个seq，用来表示哪些数据是被对方接收到的。两次握手的话，最多只能保证客户端的seq被服务端确认了，但是服务端却不知道自己的seq有没有被客户端确认。
 
另外一个**不太准确**的解释：client发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，直到某个时间才到达server，本来这已经是一个失效的报文，但是server端接收到这个请求报文后，还是会想client发出确认的报文，表示同意连接。假如不采用三次握手，那么只要server发出确认，新的建立就连接了，但其实这个请求是失效的请求，client是不会理睬server的确认信息，也不会向服务端发送确认的请求，但是server认为新的连接已经建立起来了，并一直等待client发来数据，这样，server的很多资源就没白白浪费掉了，采用三次握手就是为了防止这种情况的发生，server会因为收不到确认的报文，就知道client并没有建立连接。这就是三次握手的作用。
 
 ![此处输入图片的描述][10]
 
 三次握手的过程如上图所示，下面介绍一下四次挥手的过程。
 
 ![此处输入图片的描述][11]
 
 第一次握手：TCP发送一个FIN(结束)，用来关闭客户到服务端的连接。

第二次握手：服务端收到这个FIN，他发回一个ACK(确认)，确认收到序号为收到序号+1，和SYN一样，一个FIN将占用一个序号。

第三次握手：服务端发送一个FIN(结束)到客户端，服务端关闭客户端的连接。

第四次握手：客户端发送ACK(确认)报文确认，并将确认的序号+1，这样关闭完成。

**为什么是四次挥手？**

可能有人会有疑问，tcp我握手的时候为何ACK(确认)和SYN(建立连接)是一起发送。挥手的时候为什么是分开的时候发送呢.
    因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭             SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
    
    

 **1. session解决用户登录信息保存的例子**
 
 https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#8-session
 
 
 除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 **Session存储在服务器端**，存储在服务器端的信息更加安全。

Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis这种内存型数据库中，效率会更高。
 
 使用 Session 维护用户登录状态的过程如下：

 - 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
 - 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
 - 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie值存入浏览器中；
 - 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis
   中取出用户信息，继续之前的业务操作。

应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。

 **1. Cookie 与 Session 选择（区别）**
 

 - Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session；
 - Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie
   值进行加密，然后在服务器进行解密；
 - 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

lll

 **1. HTTPs协议**
 
 https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#六https
 
 HTTP 有以下安全性问题：
 

 - 使用明文进行通信，内容可能会被窃听；
 - 不验证通信方的身份，通信方的身份有可能遭遇伪装；
 - 无法证明报文的完整性，报文有可能遭篡改。

HTTPs 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPs 使用了隧道进行通信。

通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。

![此处输入图片的描述][12]

HTTPs采用了对称、非对称加密结合的方式来进行数据的交互。使用非对称加密技术加密对称加密的秘钥，然后使用对称加密的秘钥去加密传输的数据。

这样做的好处是，利用了对称加密的加解密过程快速的优点，提高https的效率。

记住非对称加密的时候，使用的是公钥加密，私钥解密。

同样的，非对称加密也可以用于签名，这时候就是私钥签名，公钥验签。

非对称加密的公私钥都是服务器产生的，这个很好理解，因为如果公私钥匙客户端产生的，那么如果有多个客户端，那么服务器就要存很多歌客户端的公钥，这是没有必要的，还不如服务器产生一对公私钥，然后所有的客户端都获得该服务器的公钥，节约资源。

https的加解密过程如下图所示：

![此处输入图片的描述][13]

至于上面提到的公私钥的产生，可以使用CA，由服务端去向CA认证机构申请CA证书。然后在https通信的时候，需要客户端去下载CA证书，取出其中的公钥，使用该公钥加密对称秘钥，传输给服务器，然后服务器解密，使用该对称公钥，双方就可以安全通信了。

https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#七http20

http2.0相对于http1.x具有以下一些区别或优点：

 - HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。
 - 在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。
 - HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。
 - HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。HTTP/2.0要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。不仅如此，HTTP/2.0 也使用 Huffman编码对首部字段进行压缩。

ll

 **1. springboot的启动过程**
 
 下面我们简要分析一下springboot的启动过程,看看为什么springboot可以使用如此简介的代码实现springboot的pure java式的启动过程,在讲springboot的启动过程之前我们先复习一下之前spring的bean的实例化过程:
 
 https://github.com/WQZ321123/learn/blob/master/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86.md#spring-bean的生命周期
 
 这里重复一下:
 
 下面的流程可以参考https://github.com/WQZ321123/spring-demo/blob/master/src/main/java/com/example/demo/initial/AbstractInit.java类:
 
 1. 实例化一个Bean－－也就是我们常说的new；
 2. 按照Spring上下文对实例化的Bean进行配置－－也就是IOC注入；
 3. 如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring配置文件中Bean的id值
 4. 如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory(setBeanFactory(BeanFactory)传递的是Spring工厂自身（可以用这个方式来获取其它Bean，只需在Spring配置文件中配置一个普通的Bean就可以）；
 5. 如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文（同样这个方式也可以实现步骤4的内容，但比4更好，因为ApplicationContext是BeanFactory的子接口，有更多的实现方法）；
 6. 如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object
    obj, String
    s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术；
 7. 如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。
 8. 如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object
    obj, String s)方法、；
 9. 注：以上工作完成以后就可以应用这个Bean了，那这个Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Spring配置文件中也可以配置非Singleton，这里我们不做赘述。
 
 10. 当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用那个其实现的destroy()方法；
 11. 最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。

上面的第6部和第8部,所谓的关联了BeanPostProcessor接口,其实就是只要你自己实现了BeanPostProcessor接口,可以参考https://github.com/WQZ321123/spring-demo/blob/master/src/main/java/com/example/demo/initial/CustomBeanPostProcessor.java

另外,注意一下@PostConstruct这个注解,它并不属于spring,属于java注解,它的作用类似于init-method(),所以执行时机也就在第7步.

如果实例化的bean还是实现了InitializingBean接口的话,那么afterPropertiesSet()方法(该方法中使用@PostConstruct注解是不会生效的)执行的时机是在第8步之前.下面是InitializingBean接口的定义以及https://github.com/WQZ321123/spring-demo工程中BInit对象的实例化过程的部分日志:
```java
package org.springframework.beans.factory;

public interface InitializingBean {
    void afterPropertiesSet() throws Exception;
}
```

BInit实例化日志:
```java
2018-12-09 15:34:51.976  INFO 8238 --- [  restartedMain] com.example.demo.initial.AbstractInit    : BInit.Construct, bean:BInit(aInit=null)
2018-12-09 15:34:51.981  INFO 8238 --- [  restartedMain] com.example.demo.initial.AbstractInit    : BInit.BeanNameAware.setBeanName:BInit, bean:BInit(aInit=AInit(cInit=null, hello=hello word))
2018-12-09 15:34:51.981  INFO 8238 --- [  restartedMain] com.example.demo.initial.AbstractInit    : BInit.BeanFactoryAware.setBeanFactory, bean:BInit(aInit=AInit(cInit=null, hello=hello word))
2018-12-09 15:34:51.981  INFO 8238 --- [  restartedMain] com.example.demo.initial.AbstractInit    : BInit.ApplicationContextAware.setApplicationContext, bean:BInit(aInit=AInit(cInit=null, hello=hello word))
2018-12-09 15:34:51.981  INFO 8238 --- [  restartedMain] c.e.d.initial.CustomBeanPostProcessor    : CustomBeanPostProcessor.BeanPostProcessor.postProcessBeforeInitialization,beanName:BInit, bean:BInit(aInit=AInit(cInit=null, hello=hello word))
2018-12-09 15:34:51.981  INFO 8238 --- [  restartedMain] com.example.demo.initial.AbstractInit    : BInit.PostConstruct, bean:BInit(aInit=AInit(cInit=null, hello=hello word))
2018-12-09 15:34:51.981  INFO 8238 --- [  restartedMain] com.example.demo.initial.AbstractInit    : BInit.InitializingBean.afterPropertiesSet, bean:BInit(aInit=AInit(cInit=null, hello=hello word))
2018-12-09 15:34:51.981  INFO 8238 --- [  restartedMain] c.e.d.initial.CustomBeanPostProcessor    : CustomBeanPostProcessor.BeanPostProcessor.postProcessAfterInitialization, beanName:BInit, bean:BInit(aInit=AInit(cInit=null, hello=hello word))
```
 
 
 https://github.com/WQZ321123/spring-demo
 
 这里参考了才哥之前讲的springboot的示例代码:
 ```java
 import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
 ```
 一般分析springboot的启动过程都是从@SpringBootApplication注解和SpringApplication.run()方法入手的.
 
 https://www.cnblogs.com/shamo89/p/8184960.html
 
 先上一张图,这张图大概讲解了springboot的启动过程:
 
 ![此处输入图片的描述][14]
 
 然后我们看一下springboot的@SpringBootApplication注解:
 ```java
 @Target(ElementType.TYPE)            // 注解的适用范围，其中TYPE用于描述类、接口（包括包注解类型）或enum声明
@Retention(RetentionPolicy.RUNTIME)  // 注解的生命周期，保留到class文件中（三个生命周期）
@Documented                          // 表明这个注解应该被javadoc记录
@Inherited                           // 子类可以继承该注解
@SpringBootConfiguration             // 继承了Configuration，表示当前是注解类
@EnableAutoConfiguration             // 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助
@ComponentScan(excludeFilters = {    // 扫描路径设置（具体使用待确认）
        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
...
}
 ```
 虽然定义使用了多个Annotation进行了原信息标注，但实际上重要的只有三个Annotation：

 - @Configuration（@SpringBootConfiguration点开查看发现里面还是应用了@Configuration）
 - @EnableAutoConfiguration
 - @ComponentScan


@Configuration主要标志某个类是一个配置类,在这里表示springboot的启动类本身也是spring的一个配置类.

@ComponentScan注解功能其实就是自动扫描并加载符合条件的组件或者bean定义,最终将这些bean定义加载到IoC容器中。注意,**默认**Spring框架实现会从声明@ComponentScan所在类的package进行扫描。所以,所以SpringBoot的启动类最好是放在root package下,这样就可以省去配置basePackages了.

@EnableAutoConfiguration借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器,这个注解相对来说最为重要,下面详细讲一下这个注解.

@EnableAutoConfiguration作为一个复合Annotation,其自身定义关键信息如下：
```java
@SuppressWarnings("deprecation")
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage   //自动配置包
@Import(EnableAutoConfigurationImportSelector.class)  //导入自动配置的组件
public @interface EnableAutoConfiguration {
    ...
}
```

对于@AutoConfigurationPackage注解,看一下它的定义:
```java
package org.springframework.boot.autoconfigure;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.springframework.context.annotation.Import;

/**
 * Indicates that the package containing the annotated class should be registered with
 * {@link AutoConfigurationPackages}.
 *
 * @author Phillip Webb
 * @since 1.3.0
 * @see AutoConfigurationPackages
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(AutoConfigurationPackages.Registrar.class)
public @interface AutoConfigurationPackage {

}
```

可以看到这个注解使用了Registrar类对象,源码如下:
```java
/**
	 * {@link ImportBeanDefinitionRegistrar} to store the base package from the importing
	 * configuration.
	 */
	@Order(Ordered.HIGHEST_PRECEDENCE)
	static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {

		@Override
		public void registerBeanDefinitions(AnnotationMetadata metadata,
				BeanDefinitionRegistry registry) {
			register(registry, new PackageImport(metadata).getPackageName());
		}

		@Override
		public Set<Object> determineImports(AnnotationMetadata metadata) {
			return Collections.<Object>singleton(new PackageImport(metadata));
		}

	}
```

上面代码中的
```java
new PackageImport(metadata).getPackageName()
```
其实就是返回了当前主程序类的 **同级以及子级**     的包组件。

再看一下@Import(EnableAutoConfigurationImportSelector.class) 注解:

![此处输入图片的描述][15]

从图中可以看出  AutoConfigurationImportSelector 继承了 DeferredImportSelector 继承了 ImportSelector,

看一下AutoConfigurationImportSelector中如下的一个方法
```java
@Override
	public String[] selectImports(AnnotationMetadata annotationMetadata) {
		if (!isEnabled(annotationMetadata)) {
			return NO_IMPORTS;
		}
		try {
			AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader
					.loadMetadata(this.beanClassLoader);
			AnnotationAttributes attributes = getAttributes(annotationMetadata);
			List<String> configurations = getCandidateConfigurations(annotationMetadata,
					attributes);
			configurations = removeDuplicates(configurations);
			configurations = sort(configurations, autoConfigurationMetadata);
			Set<String> exclusions = getExclusions(annotationMetadata, attributes);
			checkExcludedClasses(configurations, exclusions);
			configurations.removeAll(exclusions);
			configurations = filter(configurations, autoConfigurationMetadata);
			fireAutoConfigurationImportEvents(configurations, exclusions);
			return configurations.toArray(new String[configurations.size()]);
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
```

它会去加载  public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";外部文件。这个外部文件，有很多自动配置的类。

spring下有多个jar包下都有这个文件,如下图:

![此处输入图片的描述][16]

@EnableAutoConfiguration自动配置的魔法骑士就变成了：从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableutoConfiguration对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。

![此处输入图片的描述][17]

总结上面的过程,得出下面的流程图:

![此处输入图片的描述][18]

**下面**，我们讲解一下SpringApplication的静态run()方法，流程如下：

1、首先run方法会创建一个**SpringApplication对象实例**，然后调用这个创建好的SpringApplication的实例方法。
```java
/**
	 * Static helper that can be used to run a {@link SpringApplication} from the
	 * specified source using default settings.
	 * @param source the source to load
	 * @param args the application arguments (usually passed from a Java main method)
	 * @return the running {@link ApplicationContext}
	 */
	public static ConfigurableApplicationContext run(Object source, String... args) {
		return run(new Object[] { source }, args);
	}
	
....
	/**
	 * Static helper that can be used to run a {@link SpringApplication} from the
	 * specified sources using default settings and user supplied arguments.
	 * @param sources the sources to load
	 * @param args the application arguments (usually passed from a Java main method)
	 * @return the running {@link ApplicationContext}
	 */
	public static ConfigurableApplicationContext run(Object[] sources, String[] args) {
		return new SpringApplication(sources).run(args);
	}
```
在new SpringApplication对象的时候，其构造函数内部调用了initialize()方法，构造函数和initialize方法的实现如下所示：
```java
/**
	 * Create a new {@link SpringApplication} instance. The application context will load
	 * beans from the specified sources (see {@link SpringApplication class-level}
	 * documentation for details. The instance can be customized before calling
	 * {@link #run(String...)}.
	 * @param sources the bean sources
	 * @see #run(Object, String[])
	 * @see #SpringApplication(ResourceLoader, Object...)
	 */
	public SpringApplication(Object... sources) {
		initialize(sources);
	}
	
	...
	@SuppressWarnings({ "unchecked", "rawtypes" })
	private void initialize(Object[] sources) {
		if (sources != null && sources.length > 0) {
			this.sources.addAll(Arrays.asList(sources));
		}
		this.webEnvironment = deduceWebEnvironment();
		setInitializers((Collection) getSpringFactoriesInstances(
				ApplicationContextInitializer.class));
		setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
		this.mainApplicationClass = deduceMainApplicationClass();
	}
```

initialize()方法主要完成了以下一些功能：

 - deduceWebEnvironment()方法，查看当前ClassLoader是否有"javax.servlet.Servlet","org.springframework.web.context.ConfigurableWebApplicationContext"两个类，有的话就将this.webEnvironment设置为true，否则false；
 - setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));方法主要完成在应用的classpath中查找并加载所有可用的ApplicationContextInitializer；
 - setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));方法主要完成在应用的classpath中查找并加载所有可用的ApplicationListener；
 - 推断并设置main方法的定义类

**SpringApplication实例化**完成以后，就开始执行静态run方法了。
```java
/**
	 * Run the Spring application, creating and refreshing a new
	 * {@link ApplicationContext}.
	 * @param args the application arguments (usually passed from a Java main method)
	 * @return a running {@link ApplicationContext}
	 */
	public ConfigurableApplicationContext run(String... args) {
		StopWatch stopWatch = new StopWatch();
		stopWatch.start();
		ConfigurableApplicationContext context = null;
		FailureAnalyzers analyzers = null;
		configureHeadlessProperty();
		SpringApplicationRunListeners listeners = getRunListeners(args);
		listeners.starting();
		try {
			ApplicationArguments applicationArguments = new DefaultApplicationArguments(
					args);
			ConfigurableEnvironment environment = prepareEnvironment(listeners,
					applicationArguments);
			Banner printedBanner = printBanner(environment);
			context = createApplicationContext();
			analyzers = new FailureAnalyzers(context);
			prepareContext(context, environment, listeners, applicationArguments,
					printedBanner);
			refreshContext(context);
			afterRefresh(context, applicationArguments);
			listeners.finished(context, null);
			stopWatch.stop();
			if (this.logStartupInfo) {
				new StartupInfoLogger(this.mainApplicationClass)
						.logStarted(getApplicationLog(), stopWatch);
			}
			return context;
		}
		catch (Throwable ex) {
			handleRunFailure(context, listeners, analyzers, ex);
			throw new IllegalStateException(ex);
		}
	}
```

 - run方法首先是加载所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener，并添加到SpringApplicationRunListeners中（其实就是个ArrayList中）；
 - 启动所有的Listener，开始监听，listeners.starting();，内部使用了多线程来启动listener
 - prepareEnvironment(listeners,applicationArguments);，创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）
 - prepareContext(context, environment, listeners, applicationArguments,printedBanner);将前面创建的各种对象放到context上下文环境中。
 - refreshContext(context);

这个方法比较重要，我们细看一下：
```java
@Override
	public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			// Prepare this context for refreshing.
			prepareRefresh();

			// Tell the subclass to refresh the internal bean factory.
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
				initMessageSource();

				// Initialize event multicaster for this context.
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				onRefresh();

				// Check for listener beans and register them.
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn("Exception encountered during context initialization - " +
							"cancelling refresh attempt: " + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring's core, since we
				// might not ever need metadata for singleton beans anymore...
				resetCommonCaches();
			}
		}
	}
```

 - 首先这个方法一进来就加锁了synchronized (this.startupShutdownMonitor)
 - 然后是prepareRefresh，其实就是设置启动时间，激活flag，以及实例化一些配置项目
 - 然后就是获取beanFactory，并且执行bean processors的注册，实例化事件传播器，消息源，注册所有的listener
 - 实例化所有的non-lazy-init的singleton类型的bean
 - 最后发布相应的事件

 查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。
 
 正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）
 
 springboot的run方法的过程大致可以归纳为如下图的样子：
 
 ![此处输入图片的描述][19]
 
 
 
 
 
 
 
 
 
 
 
 

 **1. springboot如何检测循环依赖?**
 
 https://blog.csdn.net/u010853261/article/details/77940767
 
 spring的循环依赖一般分为两种,一是构造器循环依赖,二是属性或者setter依赖.第一种情况spring是不能解决的,第二种情况,spring可以解决.
 
 Spring的单例对象的初始化主要分为三步： 
 
 ![此处输入图片的描述][20]
 
 

 1. createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象(所以说,构造器的循环以来是不能解决的)
 2. populateBean：填充属性，这一步主要是多bean的依赖属性进行填充
 3. initializeBean：调用init-method方法或者InitializingBean.afterPropertiesSet方法。

spring为了解决循环依赖,使用了三级缓存,分别如下:
```java
/** Cache of singleton objects: bean name --> bean instance */
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);

/** Cache of early singleton objects: bean name --> bean instance */
private final Map<String, Object> earlySingletonObjects = new HashMap<String, Object>(16);

/** Cache of singleton factories: bean name --> ObjectFactory */
private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<String, ObjectFactory<?>>(16);
```

这三级缓存分别指： 

 - singletonObjects：单例对象的cache(第一级)
 - earlySingletonObjects ：提前暴光的单例对象的Cache(第二级)
 - singletonFactories ： 单例对象工厂的cache(第三级)

下面代码展示了如何从缓存中获取bean实例对象:
```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
        synchronized (this.singletonObjects) {
            singletonObject = this.earlySingletonObjects.get(beanName);
            if (singletonObject == null && allowEarlyReference) {
                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                if (singletonFactory != null) {
                    singletonObject = singletonFactory.getObject();
                    this.earlySingletonObjects.put(beanName, singletonObject);
                    this.singletonFactories.remove(beanName);
                }
            }
        }
    }
    return (singletonObject != NULL_OBJECT ? singletonObject : null);
}
```

分析getSingleton()的整个过程，Spring首先从一级缓存singletonObjects中获取。如果获取不到，并且对象正在创建中，就再从二级缓存earlySingletonObjects中获取。如果还是获取不到且允许singletonFactories通过getObject()获取，就从三级缓存singletonFactory.getObject()(三级缓存)获取，如果获取到了从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是从三级缓存移动到了二级缓存。

从上面三级缓存的分析，我们可以知道，Spring解决循环依赖的诀窍就在于singletonFactories这个三级cache。这个cache的value类型是ObjectFactory，定义如下：
```java
public interface ObjectFactory<T> {

	/**
	 * Return an instance (possibly shared or independent)
	 * of the object managed by this factory.
	 * @return the resulting instance
	 * @throws BeansException in case of creation errors
	 */
	T getObject() throws BeansException;
}
```
在AbstractAutowireCapableBeanFactory类的doCreateBean方法内部调用了addSingletonFactory()方法,该方法引用了ObjectFactory对象:
```java
/**
	 * Add the given singleton factory for building the specified singleton
	 * if necessary.
	 * <p>To be called for eager registration of singletons, e.g. to be able to
	 * resolve circular references.
	 * @param beanName the name of the bean
	 * @param singletonFactory the factory for the singleton object
	 */
	protected void addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory) {
		Assert.notNull(singletonFactory, "Singleton factory must not be null");
		synchronized (this.singletonObjects) {
			if (!this.singletonObjects.containsKey(beanName)) {
				this.singletonFactories.put(beanName, singletonFactory);
				this.earlySingletonObjects.remove(beanName);
				this.registeredSingletons.add(beanName);
			}
		}
	}
```

这里就是解决循环依赖的关键，这段代码发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来(调用了构造器)。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。

此时,spring就解决了循环依赖的问题.

 **1. 工作中遇到了哪些比较难的问题？如何解决的？**
 
 之前遇到过，在trust底层处理区块特别慢，原本1秒可以产生5个区块左右，但是当时30-50秒才产生一个区块。查看服务器内存占用特别高，但是进程还在。一般我们在服务器内存出现OOM之前可以在启动命令中加上-XX:+HeapDumpOnOutOfMemoryError，这样出现OOM的时候就会将堆栈信息保存下来。
  这里我们使用如下命令：
 ```java
 jmap -dump:format=b,file=3.hprof 11459
 ```
 生成PID=11459的堆文件，使用MAT打开。分析占用内存最大的对象，发现是一个ThreadLocal对象，它内部存储的map对象的value是一个ArrayList，list中的数据量非常大，占去了整个内存的90%多。
 
 通过搜索源码，定位到我们代码中使用的一个性能日志输出的工具类Profiler，它内部为了统计各个方法的执行耗时，使用到了ThreadLocal变量来应对多线程处理的情况。
 
 首先看一下Porfiler类的方法和属性：
 
 ![此处输入图片的描述][21]
 
 我们一般常用的方法就是start、enter、release、getDuration、dump方法，外加一个Entry内部类，先贴出他们的源码：
 ```java
 /**
     * 代表一个计时单元。
     */
    public static final class Entry {
        private final List subEntries = new ArrayList(4);
        private final Object message;
        private final Entry parentEntry;
        private final Entry firstEntry;
        private final long baseTime;
        private final long startTime;
        private long endTime;

        /**
         * 创建一个新的entry。
         *
         * @param message     entry的信息，可以是<code>null</code>
         * @param parentEntry 父entry，可以是<code>null</code>
         * @param firstEntry  第一个entry，可以是<code>null</code>
         */
        private Entry(Object message, Entry parentEntry, Entry firstEntry) {
            this.message = message;
            this.startTime = System.currentTimeMillis();
            this.parentEntry = parentEntry;
            this.firstEntry = (firstEntry != null) ? firstEntry : this;
            this.baseTime = (firstEntry == null) ? 0 : firstEntry.startTime;
        }
        。。。
        
        
/**
     * 开始计时。
     *
     * @param message 第一个entry的信息
     */
    public static void start(String message) {
        ENTRY_STACK.set(new Entry(message, null, null));
    }
    
    
    
    /**
     * 开始一个新的entry，并计时。
     *
     * @param message 新entry的信息
     */
    public static void enter(String message) {
        Entry currentEntry = getCurrentEntry();

        if (currentEntry != null) {
            currentEntry.enterSubEntry(message);
        }
    }
    
    
    /**
     * 结束最近的一个entry，记录结束时间。
     */
    public static void release() {
        Entry currentEntry = getCurrentEntry();

        if (currentEntry != null) {
            currentEntry.release();
        }
    }
    
    
    /**
     * 取得耗费的总时间。
     *
     * @return 耗费的总时间，如果未开始计时，则返回<code>-1</code>
     */
    public static long getDuration() {
        Entry entry = (Entry)ENTRY_STACK.get();

        if (entry != null) {
            return entry.getDuration();
        } else {
            return -1;
        }
    }
    

    /**
     * 列出所有的entry。
     *
     * @return 列出所有entry，并统计各自所占用的时间
     */
    public static String dump() {
        return dump("", "");
    }
 ```
 
一般我们的正常用法是：
```java
    private void testProfiler(){
        Profiler.start("1");
        Profiler.enter("1.1");
        Profiler.release();
        Profiler.enter("1.2");
        Profiler.enter("1.2.1");
        Profiler.release();
        Profiler.enter("1.2.2");
        Profiler.release();
        Profiler.release();
        Profiler.enter("1.3");
        Profiler.release();
        Profiler.release();
    }
```
上面的调用关系可以打印出父方法的总耗时，以及子方法各自的耗时。上面代码的调用如下图所示：

![此处输入图片的描述][22]

当时异常的情况是，调用了一次start  多次调用enter 而没有调用start

 **1. 各种排序算法的时间复杂度**
 
 ![此处输入图片的描述][23]

 **1. 快速排序**
 
 http://developer.51cto.com/art/201403/430986.htm
 
 排序的思路，我们可以参考连接里的几张图片，形象生动，搬运如下：
 
 ![此处输入图片的描述][24]
 
 ![此处输入图片的描述][25]
 
 ![此处输入图片的描述][26]
 
 ![此处输入图片的描述][27]
 
 ![此处输入图片的描述][28]
 
 ![此处输入图片的描述][29]
 
 ![此处输入图片的描述][30]
 
 ![此处输入图片的描述][31]
 
 ![此处输入图片的描述][32]
 
 ```java
 package com.audi.offer.sort;

import java.util.Arrays;

public class QuickSort {
    public static void main(String[] args) {
//        int a[] = {5, 7, 9, 10, 18, 1, 5, 11, 0, 20, 11, 2, 3, 45, 1, 100, 12};
        int a[] = {5, 7, 9, 10, 18, 1, 5, 11, 0, 20, 11};
        System.out.println("a before:" + Arrays.toString(a));
        QuickSort quickSort = new QuickSort();
        quickSort.sort(a, 0, a.length - 1);
        System.out.println("a after:" + Arrays.toString(a));
    }

    /**
     * @param
     * @return
     * @desc 从小到大排序（升序）
     */
    public void sort(int[] a, int i, int j) {
        if (null == a || i >= j) {
            return;
        }
        int left = i;
        int right = j;
        while (left < right) {
            while (left < right && a[i] < a[right]) {
                right--;
            }
            while (left < right && a[i] >= a[left]) {
                left++;
            }
            if (left < right) {
                swap(a, left, right);
            }
        }
        if (i < left) {
            swap(a, i, left);
        }
        sort(a, i, left - 1);
        sort(a, left + 1, j);

    }

    private void swap(int[] a, int left, int right) {
        int temp = a[left];
        a[left] = a[right];
        a[right] = temp;
    }
}
 ```
 
 代码输出：
 ```java
a before:[5, 7, 9, 10, 18, 1, 5, 11, 0, 20, 11]
a after:[0, 1, 5, 5, 7, 9, 10, 11, 11, 18, 20]
 ```
 
 

 **1. 冒泡排序**

https://www.cnblogs.com/chengxiao/p/6103002.html

![此处输入图片的描述][33]

冒泡排序本质上来说还是很简单的,每次内循环结束以后,数组最大的元素会被放置到当前子数组的末尾.

```java
// 从小到大排序
    public static void bubbleSort(int[] a) {
        if (null == a || a.length < 2) {
            return;
        }
        for (int i = 0; i < a.length - 1; i++) {
            for (int j = 0; j < a.length - i - 1; j++) {
                if (a[j] > a[j + 1]) {
                    int temp = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = temp;
                }
            }
        }
    }
```

java基本类型占几个字节？
==============

| 整数类型 | byte    | 1B         | -128~127               |
| -------- | ------- | ---------- | ---------------------- |
|          | short   | 2B         | -32768~32767           |
|          | int     | 4B         | -2147483648~2147483647 |
|          | long    | 8B         | -2^63~2^63-1           |
| 字符类型 | char    | 2B         |                        |
| 浮点型   | float   | 4B         |                        |
|          | double  | 8B         |                        |
| 布尔型   | boolean | 一般占用1B |                        |

需要指出的是：所有的正无穷大都是相等的，所有的负无穷大也是相等的。
NaN不与任何数值相等，与NaN也不相等。浮点数除以0会得到正/负无穷大，整数除以0会抛出异常。

Java中的NIO
=========

NIO也就是New Input/Output，新IO。
NIO和IO目的相同，都是用于进行输入/输出。但是新IO采用内存映射文件的方式来处理IO。新IO将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样来访问文件了（这种方式模拟了操作系统上的虚拟内存的概念）。
Java中与NIO相关的包如下：

 - java.nio：主要包含各种和Buffer相关的类
 - java.nio.channels：主要包含与Channel和Selector相关的类

java.nio.charset：主要包含与字符集相关的类
java.nio.channels.spi
java.nio.charset.spi

一致性 Hash 算法
===========

一致性Hash算法主要是为了解决分布式环境下,数据均匀映射散列分布的问题.具体可以参考一下[这里][1].


  但是如上的链接对于虚拟节点的讲解不是很清除,我又搜索整理了一下资料.
  
  https://blog.csdn.net/baidu_30000217/article/details/53671716
  
  发现这个链接对于虚拟节点部分讲解挺不错的.引入虚拟节点以后:
  ![此处输入图片的描述][2]
  
  此时，对象到“虚拟节点”的映射关系为：

objec1->cache C2 ； objec2->cache A1 ； objec3->cache C1 ； objec4->cache A2 ；
注意,objec2,objec3,objec4并未在上图中标出,但是位置我们应该知道他们的位置.例如objec2应该在cache C2和cache A1之间.

此时,又因为cache C2和cache C1都会映射到cache C上.同理,cache A1和cache A2也会映射到cache A上.因此,平衡性有了很大提高。
  


  [1]: https://github.com/crossoverJie/JCSprout/blob/master/MD/Consistent-Hash.md
  [2]: https://github.com/WQZ321123/learn/blob/master/image/consistentHash/virtualNode.png?raw=true


 

 
 

 
 
 

 

 

 
 
 
 

 
 

 

 
 
 
 
 

 
 

 
 
 

 

 
 
 

 
 
 
 
 

 
 

 
 


  [1]: https://www.jianshu.com/p/05d44e107470
  [2]: https://github.com/WQZ321123/learn/blob/master/image/interview/VM.png?raw=true
  [3]: https://github.com/WQZ321123/learn/blob/master/image/interview/Http%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84.png?raw=true
  [4]: https://github.com/WQZ321123/learn/blob/master/image/interview/http%E5%93%8D%E5%BA%94%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.jpg?raw=true
  [5]: https://github.com/WQZ321123/learn/blob/master/image/interview/atomic%E5%8C%85.png?raw=true
  [6]: https://github.com/WQZ321123/learn/blob/master/image/interview/0-1%EF%BC%880%EF%BC%89.jpg?raw=true
  [7]: https://github.com/WQZ321123/learn/blob/master/image/interview/0-1%EF%BC%881%EF%BC%89.jpg?raw=true
  [8]: https://github.com/WQZ321123/learn/blob/master/image/interview/0-1%EF%BC%882%EF%BC%89.jpg?raw=true
  [9]: https://github.com/WQZ321123/learn/blob/master/image/interview/%E8%B7%B3%E8%B7%83%E8%A1%A8.jpg?raw=true
  [10]: https://github.com/WQZ321123/learn/blob/master/image/interview/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png?raw=true
  [11]: https://github.com/WQZ321123/learn/blob/master/image/interview/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png?raw=true
  [12]: https://github.com/WQZ321123/learn/blob/master/image/interview/https.jpg?raw=true
  [13]: https://github.com/WQZ321123/learn/blob/master/image/interview/How-HTTPS-Works.png?raw=true
  [14]: https://github.com/WQZ321123/learn/blob/master/image/interview/springboot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%9B%BE.png?raw=true
  [15]: https://github.com/WQZ321123/learn/blob/master/image/interview/AutoConfigurationImportSelector%E7%9A%84%E7%B1%BB%E5%9B%BE.png?raw=true
  [16]: https://github.com/WQZ321123/learn/blob/master/image/interview/spring.factories.png?raw=true
  [17]: https://github.com/WQZ321123/learn/blob/master/image/interview/autoconfigure.png?raw=true
  [18]: https://github.com/WQZ321123/learn/blob/master/image/interview/springboot.png?raw=true
  [19]: https://github.com/WQZ321123/learn/blob/master/image/interview/springboot%E7%9A%84run%E6%96%B9%E6%B3%95.png?raw=true
  [20]: https://github.com/WQZ321123/learn/blob/master/image/interview/Spring%E7%9A%84%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AD%A5%E9%AA%A4.jpg?raw=true
  [21]: https://github.com/WQZ321123/learn/blob/master/image/interview/Profiler.png?raw=true
  [22]: https://github.com/WQZ321123/learn/blob/master/image/interview/Profiler%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F.jpg?raw=true
  [23]: https://github.com/WQZ321123/learn/blob/master/image/interview/sortcomplexity.jpg?raw=true
  [24]: https://github.com/WQZ321123/learn/blob/master/image/interview/quickSort1.jpg?raw=true
  [25]: https://github.com/WQZ321123/learn/blob/master/image/interview/quickSort2.jpg?raw=true
  [26]: https://github.com/WQZ321123/learn/blob/master/image/interview/quickSort3.jpg?raw=true
  [27]: https://github.com/WQZ321123/learn/blob/master/image/interview/quickSort4.jpg?raw=true
  [28]: https://github.com/WQZ321123/learn/blob/master/image/interview/quickSort5.jpg?raw=true
  [29]: https://github.com/WQZ321123/learn/blob/master/image/interview/quickSort6.jpg?raw=true
  [30]: https://github.com/WQZ321123/learn/blob/master/image/interview/quickSort7.jpg?raw=true
  [31]: https://github.com/WQZ321123/learn/blob/master/image/interview/quickSort8.jpg?raw=true
  [32]: https://github.com/WQZ321123/learn/blob/master/image/interview/quickSort9.jpg?raw=true
  [33]: https://github.com/WQZ321123/learn/blob/master/image/interview/bubblesort.png?raw=true