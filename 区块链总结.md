# 区块链总结    

标签（空格分隔）： 区块链

---

要求
==

2.精通一门语言，JAVA，C++或者GO均可，具备良好学习能力，能在短期内熟练掌握新的语言。

3.对操作系统，编译原理，网络原理，加密算法等**底层**技术有相当的兴趣及研究。

4.熟悉区块链的**原理**，熟悉开源项目，HyperLedger fabric、Ethereum、bitcoin、Corda；对区块链有浓厚兴趣，有区块链研发经验者优先。

5.有开源软件开发经验者优先，有大型系统架构设计经验者优先。

6.有良好的沟通协调能力和应变能力。

1、熟练掌握以太坊/比特币/区块链的**原理、机制**；
2、理解主流**共识算法**，包括不限于PoW，PoS，DPoS，PBFT，Paxos，Raft等；
3、熟悉**智能合约**和Solidity编程优先；
4、熟悉各种数据结构和算法，对密码学，安全协议和**加密算法**有研究；
5、Hyperledge， 以太坊等公开区块链项目研究或参与者

区块链
===

简单来讲，区块链是一个分布式的记账本，核心在于去中心化以及可信任链。 区块链技术的典型应用场景就是支付和清算，可以解决不同主体之间的信任问题。 区块链采用密码学的方法来保证已有数据的不可篡改性，主要包括密码学哈希函数和非对称加密（即有公钥和私钥）。

参考链接：
https://blog.csdn.net/qq_35440678/article/details/79538992

1、共识机制、共识算法
2、区块链中的密码学技术
3、智能合约和solidity编程
4、超级账本Hyperledge
 

 1. 什么是共识机制?
-----------

区块链可以看作一本记录所有交易的分布式公开帐簿，区块链网络中的每个参与者都把它看作一本所有权的权威记录。每个链上的参与方权利都是均等的，大家都可以往区块链上写入数据。
由于各个节点权利均等，没有中心化权威认证。如何保证某个节点写入区块链的数据是正确的，或者是被其他节点所认可的？
为了解决这个问题，于是就出现了共识机制。
 

 2. 主流的共识算法有哪些？
--------------
PoW、PoS、DPoS、raft、PBFT、smart-BFT

 - PoW
Proof of Work，工作量证明，该共识算法的共识结果在后续是可以推翻的，但是推翻的概率随着时间的推移会越来越小。比特币采用的就是这种共识算法。
block的版本 version
上一个block的hash值: prev_hash
需要写入的交易记录的hash树的值: merkle_root
更新时间: ntime
当前难度: nbits
挖矿的过程就是找到x使得以下等式成立：
```java
SHA256(SHA256(version + prev_hash + merkle_root + ntime + nbits + x )) < TARGET
```

 - PoS
Proof of Stake，权益证明，类似现实生活中的股东机制，拥有股份越多的人越容易获取记账权。
典型的过程是通过保证金（代币、资产、名声等具备价值属性的物品即可）来对赌一个合法的块成为新的区块，收益为抵押资本的利息和交易服务费。提供证明的保证金（例如通过转账货币记录）越多，则获得记账权的概率就越大。合法记账者可以获得收益。
PoS 是试图解决在 PoW 中大量资源被浪费的缺点。恶意参与者将存在保证金被罚没的风险，即损失经济利益。
一般的，对于 PoS 来说，需要掌握超过全网**1/3**的资源，才有可能左右最终的结果。这个也很容易理解，三个人投票，前两人分别支持一方，这时候，第三方的投票将决定最终结果。

 - DPoS
PoS 的改进算法，DPOS与POS原理相似。与POS的主要区别在于节点选举若干代理，由代理人验证和记账。
PoW机制和PoS机制虽然都能有效地解决记账行为的一致性共识问题，但是现有的比特币PoW机制纯粹依赖算力，导致专业从事挖矿的矿工群体似乎已和比特币社区完全分隔，某些矿池的巨大算力俨然成为另一个中心，这与比特币的去中心化思想相冲突。PoS机制虽然考虑到了PoW的不足，但依据权益结余来选择，会导致首富账户的权力更大，有可能支配记账权。
股份授权证明机制( Delegated Proof of Stake，DPoS)的出现正是基于解决PoW机制和PoS机制的这类不足。
DPOS机制是让每一个持有代币的人对整个系统资源当代表的人进行投票，而获得最多票数的101个代表进行交易打包计算。这个可以理解为101个矿池，而这101个矿池彼此的权利是完全相等的。那些握着代币选票的人可以随时通过投票更换这些代表（矿池），只要他们提供的算力不稳定，计算机宕机、或者试图利用手中的权力作恶，他们将会立刻被愤怒的选民门踢出整个系统，而后备代表可以随时顶上去。

 - raft
http://www.jdon.com/artichect/raft.html

raft强调节点可以宕机，但是不能作恶。也就是可以不反馈结果，但是不能故意返回错误的结果。
raft协议只要超过1/2支持就可以。

 

3. 目前主流区块链分别用的是什么共识算法？
----------------------

PoW共识算法代表：比特币&莱特币&以太坊
PoS机制代表：Peercoin & Nxt
DPoS共识算法代表：Bitshare & EOS


比特币
===

白皮书摘要
-----
现有的p2p网络，发送一笔交易，可以通过数字签名等方式，可以保证交易的有效性。但是对于双花的情景，仅仅通过数字签名是不能得到保证的。所以这个时候，比特币就提出了使用PoW方式共识来提供保证。
对于传统金融交易体系，我们一般需要一个共同信任的第三方来进行公正，保证交易的双方都是合法的。第三方的公信力，取决于第三方的维护成本，如果成本很低，那么其实第三方公信力相应的也就很低。
比特币交易的时候，假设A给B 1个BTC，那么按照白皮书描述的，过程如下：A使用自己的私钥对如下信息进行签名，hash（上一个交易+B的公钥），接收者可以对签名进行验证，从而确认交易的有效性。

源代码阅读笔记(版本git checkout 4405b78d6059e536c36974088a8ed4d9f0f29898)
-------
一个BA（BITCOIN APPLICATION）的四个主要任务：

 1. 组装交易
 2. 与其他BA节点进行交互
 3. 挖矿运算区块
 4. 保存区块
 
比特币的地址是通过公钥生成的,具体的:
```c++
String strAddress = PubKeyToAddress(GenerateNewKey());
```
GenerateNewKey函数返回一个公钥字符串,GenerateNewKey函数又依赖于AddKey函数,具体源码如下:
```c++

bool AddKey(const CKey& key)
{
    CRITICAL_BLOCK(cs_mapKeys)
    {
        mapKeys[key.GetPubKey()] = key.GetPrivKey();
        mapPubKeys[Hash160(key.GetPubKey())] = key.GetPubKey();
    }
    return CWalletDB().WriteKey(key.GetPubKey(), key.GetPrivKey());
}

vector<unsigned char> GenerateNewKey()
{
    CKey key;
    key.MakeNewKey();
    if (!AddKey(key))
        throw runtime_error("GenerateNewKey() : AddKey failed\n");
    return key.GetPubKey();
}
```
global类型map数组mapKeys存储私钥,key为公钥;global类型map数组mapPubKeys存储公钥,key为hash160(公钥).产生的公私钥对紧接着会持久化到DB,key为key.GetPubKey(), key.GetPrivKey()组成的字符串.上面代码中的CRITICAL_BLOCK宏是为了获取锁,理论上来说,为了保证线程安全,操作global变量时都应该事先获取锁.


PubKeyToAddress函数的源码如下:
```c++
static const unsigned char ADDRESSVERSION = 0;

inline string Hash160ToAddress(uint160 hash160)
{
    // add 1-byte version number to the front
    vector<unsigned char> vch(1, ADDRESSVERSION);
    vch.insert(vch.end(), UBEGIN(hash160), UEND(hash160));
    return EncodeBase58Check(vch);
}

inline string PubKeyToAddress(const vector<unsigned char>& vchPubKey)
{
    return Hash160ToAddress(Hash160(vchPubKey));
}
```
总之生成地址的步骤可以概括如下:

 1. 生成公私钥对
 2. 对公钥进行hash160(pubKey)计算hash值
 3. 将hash值编码成一个字符串,得到的就是一个地址
 
 
 比特币交易相关的类对象主要是在main.h中的COutPoint类,源码如下:
 ```c++
 class COutPoint
{
public:
    uint256 hash;
    unsigned int n;

    COutPoint() { SetNull(); }
    COutPoint(uint256 hashIn, unsigned int nIn) { hash = hashIn; n = nIn; }
    IMPLEMENT_SERIALIZE( READWRITE(FLATDATA(*this)); )
    void SetNull() { hash = 0; n = -1; }
    bool IsNull() const { return (hash == 0 && n == -1); }

    friend bool operator<(const COutPoint& a, const COutPoint& b)
    {
        return (a.hash < b.hash || (a.hash == b.hash && a.n < b.n));
    }

    friend bool operator==(const COutPoint& a, const COutPoint& b)
    {
        return (a.hash == b.hash && a.n == b.n);
    }

    friend bool operator!=(const COutPoint& a, const COutPoint& b)
    {
        return !(a == b);
    }

    string ToString() const
    {
        return strprintf("COutPoint(%s, %d)", hash.ToString().substr(0,6).c_str(), n);
    }

    void print() const
    {
        printf("%s\n", ToString().c_str());
    }
};


//
// An input of a transaction.  It contains the location of the previous
// transaction's output that it claims and a signature that matches the
// output's public key.
//
class CTxIn
{
public:
    COutPoint prevout;
    CScript scriptSig;
    unsigned int nSequence;
    ...
    }
    
    //
// An output of a transaction.  It contains the public key that the next input
// must be able to sign with to claim it.
//
class CTxOut
{
public:
    int64 nValue;
    CScript scriptPubKey;
...
};


//
// The basic transaction that is broadcasted on the network and contained in
// blocks.  A transaction can contain multiple inputs and outputs.
//
class CTransaction
{
public:
    int nVersion;
    vector<CTxIn> vin;
    vector<CTxOut> vout;
    int nLockTime;
    ...
    }
 ```
 一个CTransaction一般包含一组vin和vout,需要注意的是在vin中,包含了COutPoint prevout;它指明了当前的vin是哪一个交易的输出.
 
 任何一个**单笔**交易,要想唯一确定,那么就需要交易CTransaction的hash,以及这**单笔**交易在交易CTransaction的索引index.
 
 
 

以太坊
===

hyperledger
===========

corda
=====





