# 2022学习笔记


---

* [携程最终一致和强一致性缓存实践](#携程最终一致和强一致性缓存实践)
   * [最终一致性分布式缓存场景](#最终一致性分布式缓存场景)
      * [场景描述](#场景描述)
      * [整体方案](#整体方案)
      * [数据准确性设计](#数据准确性设计)
         * [并发控制](#并发控制)
         * [基于updateTime的更新顺序控制](#基于updatetime的更新顺序控制)
      * [数据完整性设计](#数据完整性设计)
      * [系统可用性保证](#系统可用性保证)
* [IM系统](#im系统)
* [图像识别](#图像识别)


# 携程最终一致和强一致性缓存实践

- https://mp.weixin.qq.com/s/E-chAZyHtaZOdA19mW59-Q

文章主要分为两个方面（最终一致性分布式缓存场景、强一致性分布式缓存场景）来讲解携程是如何使用缓存（redis）来降低mysql等db层面的查询压力的。

## 最终一致性分布式缓存场景

### 场景描述

经过几年演进，携程金融形成了自顶向下的多层次系统架构，如业务层、平台层、基础服务层等，其中用户信息、产品信息、订单信息等基础数据由基础平台等底层系统产生，服务于所有的金融系统，对这部分基础数据我们引入了统一的缓存服务（系统名utag），缓存数据有三大特点：**全量、准实时、永久有效**，在数据实时性要求不高的场景下，业务系统可直接调用统一的缓存查询接口。

我们的典型使用场景有：风控流程、APP入口信息提示等，而对数据一致性要求高的场景依然需要走实时的业务接口查询。引入缓存前后系统架构对比如下：

![1](1.png)

由于引入了缓存，势必会带来以下一些好处：查询的效率显著提高，查询接口层面可以做到统一，缓解底层基础服务的查询压力。

但是，也因为引入了缓存会增加系统的整体复杂度以及数据一致性问题。接下来主要从如下三个方面来讨论。

- 数据准确性：DB中单条数据的更新一定要准确同步到缓存服务。
- 数据完整性：将对应DB表的全量数据进行缓存且永久有效，从而可以替代对应的DB查询。
- 系统可用性：我们多个产品线的多个核心服务都已经接入，utag的高可用性显的尤为关键。

接下来先说明统一缓存服务的整体方案，再逐一介绍此三个关键特性的设计实现方案。

### 整体方案

简单来说就是，缓存集群服务多地部署，并且缓存更新的触发源存在多个，实现互补。缓存的更新通过mq通知到各集群。如下图所示：

![2](2.png)

### 数据准确性设计

从上图我们，可以知道触发源存在多个。不同的触发源，对缓存更新过程是一样的，整个更新步骤可抽象为4步：

- step1：触发更新，查询DB中的新数据，并发送统一的MQ
- step2：接收MQ，查询缓存中的老数据
- step3：新老数据对比，判断是否需要更新
- step4：若需要，则更新缓存

由于我们业务的大部分核心系统和所有的DB都在A地机房，所以触发源（如binlog的消费、业务MQ的接收、扫表任务的执行）都在A侧，触发更新后，第一步查询DB数据也只能在A侧查询（避免跨网络专线的数据库连接，影响性能）。查询到新数据后，发送更新缓存的MQ，两地机房的utag服务进行消费，之后进行统一的缓存更新流程。总体的缓存更新方案如下图所示：

![3](3.png)

由于有多个触发源，不同的触发源之间可能会对同一条数据的缓存更新请求出现并发，此外可能出现同一条数据在极短时间内（如1秒内）更新多次，无法区分数据更新顺序，因此需要做两方面的操作来确保数据更新的准确性。

#### 并发控制

若一条DB数据出现了多次更新，且刚好被不同的触发源触发，更新缓存时候若未加控制，可能出现数据更新错乱，如下图所示：

![4](4.png)

需要将图中的第2、3、4步进行加锁，是的缓存操作串行化。由于utag本身就依赖了redis，此处我们的分布式锁就基于redis实现。

#### 基于updateTime的更新顺序控制

携程的mysql规范要求db层面的表必须包含updateTime字段，并且设置了ON UPDATE CURRENT_TIMESTAMP。

### 数据完整性设计

### 系统可用性保证



# IM系统
- https://xie.infoq.cn/article/19e95a78e2f5389588debfb1c
- http://www.52im.net/thread-2848-1-1.html
- https://mp.weixin.qq.com/s/fMF_FjcdLiXc_JVmf4fl0w


# 图像识别




