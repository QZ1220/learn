# 2023学习笔记

标签（空格分隔）： 未分类

---

* [如何优雅的实现单例](#如何优雅的实现单例)
   * [非线程安全实现方式](#非线程安全实现方式)

# 如何优雅的实现单例

## 非线程安全实现方式
```java
public class Singleton {

    // 单例对象
    private static Singleton instance;

    private Singleton() {
        System.out.println("调用类的默认构造函数");
    }

    /**
     * 获取实例对象
     *
     * @return
     */
    public static Singleton getInstance() {
        if (null == instance) {
            System.out.println("对象为空，调用构造函数进行初始化");
            instance = new Singleton();
        }
        return instance;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 200; i++) {
            System.out.println("创建第" + i + "个线程");
            new Thread(() -> {
                System.out.println(Singleton.getInstance());
            }).start();
        }
    }
}
```
以上代码通过getInstance创建(获取)Singleton类的instance对象，在main方法中通过批量创建线程模拟并发场景调用getInstance方法，并且打印获取到的instance对象的递增，运行可以偶现（不是必现）获取到的instance对象地址一开始是一个值，后续又是另外一个值。

这就出现了线程不安全，既然使用了static修饰的变量instance，为什么还是出现了线程不安全呢？使用static修饰的引用对象，不是应该只有一个副本吗？

使用static修饰，对于引用对象却是只会有一个副本（类变量），并且在类加载的过程中会进行初始化，但是因为instance对象并未调用构造函数进行初始化，因此在类加载过程中static修饰的instance引用对象只是初始化为了null。

那么应该如何修改使得线程安全呢？

答案很简单，就是不光使用static修饰instance，并且要调用构造函数进行初始化。代码如下：
```java
public class Singleton {

    // 单例对象
    private static Singleton instance  = new Singleton();

    private Singleton() {
        System.out.println("调用类的默认构造函数");
    }

    /**
     * 获取实例对象
     *
     * @return
     */
    public static Singleton getInstance() {
        if (null == instance) {
            System.out.println("对象为空，调用构造函数进行初始化");
            instance = new Singleton();
        }
        return instance;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 200; i++) {
            System.out.println("创建第" + i + "个线程");
            new Thread(() -> {
                System.out.println(Singleton.getInstance());
            }).start();
        }
    }
}
```

但是上面这种方式其实是饿汉式的，也是只要Singleton类加载了，无论是否调用getInstance方法都会进行instance对象的初始化（比如若Singleton类还在另外一个static方法methodA()，那么使用Singleton.methodA()也会导致instance被实例化），可能会造成内存浪费。

那么如何实现懒汉式的单例呢？但是是借助synchronized关键字和violatile
关键字，代码如下：
```java
public class Singleton {

    // 单例对象  使用volatile关键字保证对象的可见性
    private static volatile Singleton instance;

    private Singleton() {
        System.out.println("调用类的默认构造函数");
    }

    /**
     * 获取实例对象
     *
     * @return
     */
    public static Singleton getInstance() {
        if (null == instance) {
            System.out.println("使用双重校验");
            synchronized (Singleton.class) {
                if (null == instance) {
                    System.out.println("对象为空，调用构造函数进行初始化");
                    instance = new Singleton();
                }
            }

        }
        return instance;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 200; i++) {
            System.out.println("创建第" + i + "个线程");
            new Thread(() -> {
                System.out.println(Singleton.getInstance());
            }).start();
        }
    }
}
```

加锁操作存在一定的性能开销，有没有更优化的实现方案，并且也是懒加载的呢？有的，使用内部类来实现：
```java
public class Singleton {

    private Singleton() {
        System.out.println("调用类的默认构造函数");
    }

    // static如果修饰类，那么只能修饰内部类
    // final关键字表示该类是不允许被继承的
    private static final class Inner {
        private static final Singleton instance = new Singleton();
    }

    /**
     * 获取实例对象
     *
     * @return
     */
    public static Singleton getInstance() {
        return Inner.instance;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 200; i++) {
            System.out.println("创建第" + i + "个线程");
            new Thread(() -> {
                System.out.println(Singleton.getInstance());
            }).start();
        }
    }
}
```


