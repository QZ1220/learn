# 2023学习笔记

标签（空格分隔）： 未分类

---

* [如何优雅的实现单例](#如何优雅的实现单例)
   * [非线程安全实现方式](#非线程安全实现方式)
* [clinit和init方法](#clinit和init方法)
* [简易实现生成消费者](#简易实现生成消费者)
   * [生产者](#生产者)
   * [消费者](#消费者)
   * [实际调用](#实际调用)
   * [结论](#结论)
* [如何保证线上服务稳定性](#如何保证线上服务稳定性)
* [Hbase](#hbase)

# 如何优雅的实现单例

## 非线程安全实现方式
```java
public class Singleton {

    // 单例对象
    private static Singleton instance;

    private Singleton() {
        System.out.println("调用类的默认构造函数");
    }

    /**
     * 获取实例对象
     *
     * @return
     */
    public static Singleton getInstance() {
        if (null == instance) {
            System.out.println("对象为空，调用构造函数进行初始化");
            instance = new Singleton();
        }
        return instance;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 200; i++) {
            System.out.println("创建第" + i + "个线程");
            new Thread(() -> {
                System.out.println(Singleton.getInstance());
            }).start();
        }
    }
}
```
以上代码通过getInstance创建(获取)Singleton类的instance对象，在main方法中通过批量创建线程模拟并发场景调用getInstance方法，并且打印获取到的instance对象的递增，运行可以偶现（不是必现）获取到的instance对象地址一开始是一个值，后续又是另外一个值。

这就出现了线程不安全，既然使用了static修饰的变量instance，为什么还是出现了线程不安全呢？使用static修饰的引用对象，不是应该只有一个副本吗？

使用static修饰，对于引用对象却是只会有一个副本（类变量），并且在类加载的过程中会进行初始化，但是因为instance对象并未调用构造函数进行初始化，因此在类加载过程中static修饰的instance引用对象只是初始化为了null。

那么应该如何修改使得线程安全呢？

答案很简单，就是不光使用static修饰instance，并且要调用构造函数进行初始化。代码如下：
```java
public class Singleton {

    // 单例对象
    private static Singleton instance  = new Singleton();

    private Singleton() {
        System.out.println("调用类的默认构造函数");
    }

    /**
     * 获取实例对象
     *
     * @return
     */
    public static Singleton getInstance() {
        if (null == instance) {
            System.out.println("对象为空，调用构造函数进行初始化");
            instance = new Singleton();
        }
        return instance;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 200; i++) {
            System.out.println("创建第" + i + "个线程");
            new Thread(() -> {
                System.out.println(Singleton.getInstance());
            }).start();
        }
    }
}
```

但是上面这种方式其实是饿汉式的，也是只要Singleton类加载了，无论是否调用getInstance方法都会进行instance对象的初始化（比如若Singleton类还在另外一个static方法methodA()，那么使用Singleton.methodA()也会导致instance被实例化），可能会造成内存浪费。

那么如何实现懒汉式的单例呢？但是是借助synchronized关键字和violatile
关键字，代码如下：
```java
public class Singleton {

    // 单例对象  使用volatile关键字保证对象的可见性
    private static volatile Singleton instance;

    private Singleton() {
        System.out.println("调用类的默认构造函数");
    }

    /**
     * 获取实例对象
     *
     * @return
     */
    public static Singleton getInstance() {
        if (null == instance) {
            System.out.println("使用双重校验");
            synchronized (Singleton.class) {
                if (null == instance) {
                    System.out.println("对象为空，调用构造函数进行初始化");
                    instance = new Singleton();
                }
            }

        }
        return instance;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 200; i++) {
            System.out.println("创建第" + i + "个线程");
            new Thread(() -> {
                System.out.println(Singleton.getInstance());
            }).start();
        }
    }
}
```

加锁操作存在一定的性能开销，有没有更优化的实现方案，并且也是懒加载的呢？有的，使用内部类来实现：
```java
public class Singleton {

    private Singleton() {
        System.out.println("调用类的默认构造函数");
    }

    // static如果修饰类，那么只能修饰内部类
    // final关键字表示该类是不允许被继承的
    private static final class Inner {
        private static final Singleton instance = new Singleton();
    }

    /**
     * 获取实例对象
     *
     * @return
     */
    public static Singleton getInstance() {
        return Inner.instance;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 200; i++) {
            System.out.println("创建第" + i + "个线程");
            new Thread(() -> {
                System.out.println(Singleton.getInstance());
            }).start();
        }
    }
}
```

# clinit和init方法

在Java中，`<clinit>`方法和`<init>`方法是两个不同的方法，分别用于类的初始化和对象的初始化。

`<clinit>`方法是类的初始化方法，由编译器自动生成，用于执行静态变量的初始化和静态代码块的执行。在类被加载时，JVM会自动调用`<clinit>`方法，保证静态变量被正确地初始化，静态代码块被正确地执行。`<clinit>`方法是线程安全的，JVM会保证在多线程环境下只有一个线程执行该方法。如果一个类没有static变量或者static代码块，那么也就不会生成`<clinit>`方法.

`<init>`方法是对象的初始化方法，由构造函数调用，用于执行对象的初始化操作。在对象被创建时，JVM会自动调用相应的构造函数，并执行其中的`<init>`方法。`<init>`方法是非线程安全的，因为它是在对象被创建时执行的，可能会被多个线程同时调用。

总的来说，`<clinit>`方法和`<init>`方法都是用于初始化的方法，但是它们的作用域不同，`<clinit>`方法是类级别的，用于初始化静态变量和静态代码块，而`<init>`方法是对象级别的，用于初始化对象的实例变量和执行构造函数中的其他操作。

# 简易实现生成消费者

借助BlockingQueue实现。

## 生产者
首先是生产者：
```java
/**
 * 生产者
 *
 * @author : wangquanzhou
 * @date : 2023/9/2 09:59
 */
public class Producer implements Runnable {

    private BlockingQueue<String> queue;

    public Producer(BlockingQueue blockingQueue) {
        this.queue = blockingQueue;
    }


    @Override
    public void run() {
        while (true) {
            try {
                queue.put(UUID.randomUUID().toString());
                System.out.println("生成者，生产元素");
                // 增加休眠操作，方便观察控制台输出
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

需要注意的是，往队列添加元素使用的是put，而不思add方法。

二者相同的是：都可以往队列尾部添加元素，并且都会执行加锁操作（put方法加的是可中断锁）。

二者不同的是：put方法在队列满时，会将当前生产线程转为等待，并且会同步唤醒消费线程；add方法在队列满时，会抛出IllegalStateException异常表示队列已满。

## 消费者

消费者的代码整体上和生产者很类似，代码如下：
```java
/**
 * 消费者
 *
 * @author : wangquanzhou
 * @date : 2023/9/2 10:16
 */
public class Consumer implements Runnable {

    private BlockingQueue<String> queue;

    public Consumer(BlockingQueue blockingQueue) {
        this.queue = blockingQueue;
    }

    @Override
    public void run() {
        while (true) {
            try {
                String s = queue.take();
                System.out.println("消费者，消费数据 " + s);
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

注意，上面代码中消费，使用的是take方法，而不是poll方法。take方法在队列空时，会将当前消费线程转为等待，并且同步唤醒生产线程；poll方法在队列为空时，会返回null。

## 实际调用
```java
   public static void main(String[] args) {
        BlockingQueue<String> queue = new ArrayBlockingQueue<>(10, true);
        Producer producer = new Producer(queue);
        new Thread(producer).start();
        System.out.println("生成者启动成功");

        Consumer consumer = new Consumer(queue);
        new Thread(consumer).start();
        System.out.println("消费者启动成功");
    }
```

## 结论

借助BlockingQueue，我们可以方便的实现生产消费者模型，并且无需关心内部的同步处理逻辑，但是要注意在生产、消费时要选择合适的方法，否则并不能正确实现功能。

# 如何保证线上服务稳定性

1. 严格代码CR
2. 上线项checklist检查
3. 平滑发布
4. 监控告警
5. 接口限流
6. 弹性伸缩
7. 容灾与备份

# Hbase

https://zhuanlan.zhihu.com/p/145551967


