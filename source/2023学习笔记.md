# 2023学习笔记

标签（空格分隔）： 未分类

---

* [如何优雅的实现单例](#如何优雅的实现单例)
   * [非线程安全实现方式](#非线程安全实现方式)
* [clinit和init方法](#clinit和init方法)

# 如何优雅的实现单例

## 非线程安全实现方式
```java
public class Singleton {

    // 单例对象
    private static Singleton instance;

    private Singleton() {
        System.out.println("调用类的默认构造函数");
    }

    /**
     * 获取实例对象
     *
     * @return
     */
    public static Singleton getInstance() {
        if (null == instance) {
            System.out.println("对象为空，调用构造函数进行初始化");
            instance = new Singleton();
        }
        return instance;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 200; i++) {
            System.out.println("创建第" + i + "个线程");
            new Thread(() -> {
                System.out.println(Singleton.getInstance());
            }).start();
        }
    }
}
```
以上代码通过getInstance创建(获取)Singleton类的instance对象，在main方法中通过批量创建线程模拟并发场景调用getInstance方法，并且打印获取到的instance对象的递增，运行可以偶现（不是必现）获取到的instance对象地址一开始是一个值，后续又是另外一个值。

这就出现了线程不安全，既然使用了static修饰的变量instance，为什么还是出现了线程不安全呢？使用static修饰的引用对象，不是应该只有一个副本吗？

使用static修饰，对于引用对象却是只会有一个副本（类变量），并且在类加载的过程中会进行初始化，但是因为instance对象并未调用构造函数进行初始化，因此在类加载过程中static修饰的instance引用对象只是初始化为了null。

那么应该如何修改使得线程安全呢？

答案很简单，就是不光使用static修饰instance，并且要调用构造函数进行初始化。代码如下：
```java
public class Singleton {

    // 单例对象
    private static Singleton instance  = new Singleton();

    private Singleton() {
        System.out.println("调用类的默认构造函数");
    }

    /**
     * 获取实例对象
     *
     * @return
     */
    public static Singleton getInstance() {
        if (null == instance) {
            System.out.println("对象为空，调用构造函数进行初始化");
            instance = new Singleton();
        }
        return instance;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 200; i++) {
            System.out.println("创建第" + i + "个线程");
            new Thread(() -> {
                System.out.println(Singleton.getInstance());
            }).start();
        }
    }
}
```

但是上面这种方式其实是饿汉式的，也是只要Singleton类加载了，无论是否调用getInstance方法都会进行instance对象的初始化（比如若Singleton类还在另外一个static方法methodA()，那么使用Singleton.methodA()也会导致instance被实例化），可能会造成内存浪费。

那么如何实现懒汉式的单例呢？但是是借助synchronized关键字和violatile
关键字，代码如下：
```java
public class Singleton {

    // 单例对象  使用volatile关键字保证对象的可见性
    private static volatile Singleton instance;

    private Singleton() {
        System.out.println("调用类的默认构造函数");
    }

    /**
     * 获取实例对象
     *
     * @return
     */
    public static Singleton getInstance() {
        if (null == instance) {
            System.out.println("使用双重校验");
            synchronized (Singleton.class) {
                if (null == instance) {
                    System.out.println("对象为空，调用构造函数进行初始化");
                    instance = new Singleton();
                }
            }

        }
        return instance;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 200; i++) {
            System.out.println("创建第" + i + "个线程");
            new Thread(() -> {
                System.out.println(Singleton.getInstance());
            }).start();
        }
    }
}
```

加锁操作存在一定的性能开销，有没有更优化的实现方案，并且也是懒加载的呢？有的，使用内部类来实现：
```java
public class Singleton {

    private Singleton() {
        System.out.println("调用类的默认构造函数");
    }

    // static如果修饰类，那么只能修饰内部类
    // final关键字表示该类是不允许被继承的
    private static final class Inner {
        private static final Singleton instance = new Singleton();
    }

    /**
     * 获取实例对象
     *
     * @return
     */
    public static Singleton getInstance() {
        return Inner.instance;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 200; i++) {
            System.out.println("创建第" + i + "个线程");
            new Thread(() -> {
                System.out.println(Singleton.getInstance());
            }).start();
        }
    }
}
```

# clinit和init方法

在Java中，<clinit>方法和<init>方法是两个不同的方法，分别用于类的初始化和对象的初始化。

<clinit>方法是类的初始化方法，由编译器自动生成，用于执行静态变量的初始化和静态代码块的执行。在类被加载时，JVM会自动调用<clinit>方法，保证静态变量被正确地初始化，静态代码块被正确地执行。<clinit>方法是线程安全的，JVM会保证在多线程环境下只有一个线程执行该方法。如果一个类没有static变量或者static代码块，那么也就不会生成<clinit>方法.

<init>方法是对象的初始化方法，由构造函数调用，用于执行对象的初始化操作。在对象被创建时，JVM会自动调用相应的构造函数，并执行其中的<init>方法。<init>方法是非线程安全的，因为它是在对象被创建时执行的，可能会被多个线程同时调用。

总的来说，<clinit>方法和<init>方法都是用于初始化的方法，但是它们的作用域不同，<clinit>方法是类级别的，用于初始化静态变量和静态代码块，而<init>方法是对象级别的，用于初始化对象的实例变量和执行构造函数中的其他操作。
